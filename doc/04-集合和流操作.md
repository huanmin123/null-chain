# 集合和流操作

本文档介绍 `NullStream` 接口的使用方法，用于处理集合和数组数据。

## 创建流

### 从集合创建流

```java
// 从集合创建流（推荐方式）
List<String> names = Null.ofStream(users)
    .map(User::getName)
    .collect(Collectors.toList());

// 从 Stream 创建
Stream<String> stream = Stream.of("a", "b", "c");
List<String> list = Null.ofStream(stream)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

### 从 NullChain 创建流

```java
// 从 NullChain<Collection> 创建流
List<String> names = Null.of(users)
    .stream()
    .map(User::getName)
    .collect(Collectors.toList());

// 从 NullChain<Array> 创建流
String[] array = {"a", "b", "c"};
List<String> list = Null.of(array)
    .stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

## 流转换操作

### map() - 映射

```java
// 基本映射
List<String> names = Null.ofStream(users)
    .map(User::getName)
    .collect(Collectors.toList());

// 链式映射
List<String> upperNames = Null.ofStream(users)
    .map(User::getName)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

### mapToInt() - 映射为整数流

```java
NullIntStream intStream = Null.ofStream(users)
    .mapToInt(User::getAge);
```

### mapToLong() - 映射为长整型流

```java
NullLongStream longStream = Null.ofStream(users)
    .mapToLong(User::getId);
```

### mapToDouble() - 映射为双精度流

```java
NullDoubleStream doubleStream = Null.ofStream(users)
    .mapToDouble(User::getScore);
```

### flatMap() - 扁平化映射

```java
// 扁平化嵌套集合
List<String> allTags = Null.ofStream(users)
    .flatMap(user -> Null.ofStream(user.getTags()))
    .collect(Collectors.toList());
```

## 流过滤操作

### filter() - 过滤

```java
// 过滤成年用户
List<User> adults = Null.ofStream(users)
    .filter(user -> user.getAge() != null && user.getAge() >= 18)
    .collect(Collectors.toList());
```

### distinct() - 去重

```java
// 去重
List<String> uniqueNames = Null.ofStream(users)
    .map(User::getName)
    .distinct()
    .collect(Collectors.toList());
```

## 流排序操作

### sorted() - 自然排序

```java
// 自然排序
List<String> sortedNames = Null.ofStream(users)
    .map(User::getName)
    .sorted()
    .collect(Collectors.toList());
```

### sorted(Comparator) - 自定义排序

```java
// 按年龄排序
List<User> sortedUsers = Null.ofStream(users)
    .sorted(Comparator.comparing(User::getAge))
    .collect(Collectors.toList());
```

## 流限制操作

### limit() - 限制数量

```java
// 只取前10个
List<User> top10 = Null.ofStream(users)
    .limit(10)
    .collect(Collectors.toList());
```

### skip() - 跳过元素

```java
// 跳过前5个
List<User> remaining = Null.ofStream(users)
    .skip(5)
    .collect(Collectors.toList());
```

## 流查找操作

### findFirst() - 查找第一个

```java
// 查找第一个成年用户
User firstAdult = Null.ofStream(users)
    .filter(user -> user.getAge() != null && user.getAge() >= 18)
    .findFirst()
    .orElse(null);
```

### findAny() - 查找任意一个

```java
// 查找任意一个成年用户
User anyAdult = Null.ofStream(users)
    .filter(user -> user.getAge() != null && user.getAge() >= 18)
    .findAny()
    .orElse(null);
```

## 流聚合操作

### reduce() - 归约

```java
// 求和
Integer sum = Null.ofStream(numbers)
    .reduce(0, Integer::sum)
    .orElse(0);

// 求最大值
Integer max = Null.ofStream(numbers)
    .reduce(Integer::max)
    .orElse(0);
```

### max() - 最大值

```java
// 找年龄最大的用户
User oldest = Null.ofStream(users)
    .max(Comparator.comparing(User::getAge))
    .orElse(null);
```

### min() - 最小值

```java
// 找年龄最小的用户
User youngest = Null.ofStream(users)
    .min(Comparator.comparing(User::getAge))
    .orElse(null);
```

### count() - 计数

```java
// 统计数量
Long count = Null.ofStream(users)
    .count();
```

## 流匹配操作

### allMatch() - 全部匹配

```java
// 检查是否所有用户都是成年人
Boolean allAdults = Null.ofStream(users)
    .allMatch(user -> user.getAge() != null && user.getAge() >= 18);
```

### anyMatch() - 任意匹配

```java
// 检查是否有成年用户
Boolean hasAdult = Null.ofStream(users)
    .anyMatch(user -> user.getAge() != null && user.getAge() >= 18);
```

### noneMatch() - 无匹配

```java
// 检查是否没有未成年用户
Boolean noMinors = Null.ofStream(users)
    .noneMatch(user -> user.getAge() != null && user.getAge() < 18);
```

## 流收集操作

### collect() - 自定义收集器

```java
// 使用自定义收集器
Map<String, List<User>> grouped = Null.ofStream(users)
    .collect(Collectors.groupingBy(User::getName));
```

### toList() - 收集为列表

```java
// 收集为 ArrayList
List<String> names = Null.ofStream(users)
    .map(User::getName)
    .toList();
```

### toSet() - 收集为集合

```java
// 收集为 HashSet（自动去重）
Set<String> uniqueNames = Null.ofStream(users)
    .map(User::getName)
    .toSet();
```

### toArray() - 收集为数组

```java
// 收集为 Object 数组
Object[] names = Null.ofStream(users)
    .map(User::getName)
    .toArray();

// 收集为指定类型数组
String[] names = Null.ofStream(users)
    .map(User::getName)
    .toArray(String[]::new);
```

## 并行流

### parallel() - 转换为并行流

```java
// 并行处理
List<String> names = Null.ofStream(users)
    .parallel()
    .map(User::getName)
    .collect(Collectors.toList());
```

## 流遍历操作

### forEach() - 遍历

```java
// 遍历并执行操作
Null.ofStream(users)
    .forEach(user -> System.out.println(user.getName()));
```

### peek() - 查看元素

```java
// 查看元素但不改变流
List<String> names = Null.ofStream(users)
    .peek(user -> System.out.println("处理用户: " + user.getName()))
    .map(User::getName)
    .collect(Collectors.toList());
```

## 完整示例

```java
import com.gitee.huanminabc.nullchain.Null;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    
    public void processUsers(List<User> users) {
        // 获取所有成年用户的姓名（去重、排序）
        List<String> adultNames = Null.ofStream(users)
            .filter(user -> user.getAge() != null && user.getAge() >= 18)
            .map(User::getName)
            .distinct()
            .sorted()
            .collect(Collectors.toList());
        
        // 统计成年用户数量
        Long adultCount = Null.ofStream(users)
            .filter(user -> user.getAge() != null && user.getAge() >= 18)
            .count();
        
        // 查找年龄最大的用户
        User oldest = Null.ofStream(users)
            .max(Comparator.comparing(User::getAge))
            .orElse(null);
        
        // 检查是否所有用户都是成年人
        Boolean allAdults = Null.ofStream(users)
            .allMatch(user -> user.getAge() != null && user.getAge() >= 18);
    }
}
```

## 注意事项

1. **空值安全**：所有操作都是空值安全的，遇到 null 值会优雅处理
2. **延迟执行**：流操作是延迟执行的，只有在终结操作时才会真正执行
3. **短路操作**：某些操作（如 findFirst、anyMatch）是短路操作，找到结果后立即停止
4. **并行流**：使用并行流时要注意线程安全问题

