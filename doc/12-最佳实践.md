# 最佳实践

本文档提供 Null-Chain 框架的使用建议和常见问题解答。

## 代码规范

### 1. 使用链式调用

**推荐：**

```java
String name = Null.of(user)
    .map(User::getName)
    .map(String::toUpperCase)
    .orElse("UNKNOWN");
```

**不推荐：**

```java
String name = "UNKNOWN";
if (user != null) {
    String userName = user.getName();
    if (userName != null) {
        name = userName.toUpperCase();
    }
}
```

### 2. 合理使用默认值

**推荐：**

```java
String name = Null.of(user)
    .map(User::getName)
    .filter(n -> !n.isEmpty())
    .orElse("默认名称");
```

**不推荐：**

```java
String name = Null.of(user)
    .map(User::getName)
    .orElse(null);  // 不推荐返回 null，应该使用 orElseNull()
```

### 3. 避免过度嵌套

**推荐：**

```java
String roleName = Null.of(user)
    .map(User::getRole)
    .map(Role::getName)
    .orElse("无角色");
```

**不推荐：**

```java
String roleName = Null.of(user)
    .map(u -> {
        if (u.getRole() != null) {
            return u.getRole().getName();
        }
        return null;
    })
    .orElse("无角色");
```

## 性能优化

### 1. 尽早过滤

```java
// 推荐：先过滤再映射
List<String> names = Null.ofStream(users)
    .filter(user -> user.getAge() != null && user.getAge() >= 18)
    .map(User::getName)
    .collect(Collectors.toList());
```

### 2. 使用 ifGo 而不是 map + filter

```java
// 推荐：使用 ifGo
String result = Null.of(user)
    .ifGo(u -> u.getAge() > 18)
    .map(User::getName)
    .orElse("未成年");
```

### 3. 避免不必要的链式调用

```java
// 推荐：直接使用 orElse
String name = Null.of(user)
    .map(User::getName)
    .orElse("默认名称");

// 不推荐：不必要的链式调用
String name = Null.of(user)
    .map(User::getName)
    .or(() -> "默认名称")
    .orElse("默认名称");
```

## 错误处理

### 1. 使用 ofCheck 进行批量验证

```java
// 推荐：批量验证
Null.ofCheck(user)
    .of(User::getId)
    .of(User::getName)
    .of(User::getEmail)
    .doThrow(IllegalArgumentException.class, "用户信息不完整");
```

### 2. 使用 getSafe 进行异常安全的获取

```java
// 推荐：使用 getSafe 捕获检查异常
try {
    String name = Null.of(user)
        .map(User::getName)
        .getSafe();
} catch (NullChainCheckException e) {
    // 处理空值情况
}
```

### 3. 使用 capture 捕获未知异常

```java
// 推荐：使用 capture 捕获异常
Null.of(user)
    .map(User::getName)
    .capture(e -> {
        log.error("处理用户姓名时发生异常", e);
        // 处理异常
    });
```

## 集合处理

### 1. 使用 ofStream() 处理集合

```java
// 推荐：使用 ofStream() 处理集合
List<String> names = Null.ofStream(users)
    .map(User::getName)
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
```

### 2. 使用并行流处理大数据集

```java
// 推荐：使用并行流处理大数据集
List<String> names = Null.ofStream(users)
    .parallel()
    .map(User::getName)
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
```

## 任务编排

### 1. 合理使用任务组

```java
// 推荐：将相关任务组合在一起
NullGroupTask taskGroup = NullGroupTask.buildGroup(
    NullGroupTask.task(ValidationTask.class.getName()),
    NullGroupTask.task(ProcessingTask.class.getName()),
    NullGroupTask.task(NotificationTask.class.getName())
);
Map<String, Object> results = Null.of(input)
    .task(taskGroup)
    .orElse(new HashMap<>());
```

### 2. 使用 NF 脚本实现动态逻辑

```java
// 推荐：使用 NF 脚本实现动态逻辑
String script = "run task1(input) -> result1:String; " +
               "run task2(input) -> result2:String; " +
               "export result1, result2";
Object result = Null.of(input)
    .nfTask(script)
    .orElse(null);
```

## 常见问题

### Q1: Null-Chain 和 Optional 有什么区别？

**A:** Null-Chain 提供了比 Optional 更丰富的功能：

1. **更丰富的操作**：支持 HTTP 请求、JSON 处理、日期操作等
2. **更好的集合支持**：原生支持集合和数组操作
3. **任务编排支持**：支持自定义任务和工具
4. **并发支持**：支持任务组的并发执行
5. **日志追踪**：提供完整的操作日志追踪

### Q2: 使用 Null-Chain 会影响性能吗？

**A:** 不会。Null-Chain 采用延迟执行和短路操作，性能优异：

- **延迟执行**：只有在真正需要值的时候才会执行操作
- **短路操作**：当链变为空链时，后续操作会被跳过
- **零开销抽象**：对于明显为 null 的值，会直接返回空链，避免创建对象

### Q3: 可以在生产环境使用吗？

**A:** 可以。Null-Chain 已经过充分测试，支持 JDK 8 到最新版本，可以在生产环境使用。

### Q4: 如何处理异常？

**A:** Null-Chain 会自动处理空值异常，但不会捕获其他异常。如果需要处理其他异常，可以使用 try-catch：

```java
try {
    String result = Null.of(user)
        .map(User::getName)
        .orElse("default");
} catch (Exception e) {
    // 处理异常
}
```


### Q5: 支持哪些 Java 版本？

**A:** 支持 JDK 8 到最新版本，已经过全面测试。

### Q6: 可以序列化吗？

**A:** 可以。Null-Chain 支持序列化，可以用于网络传输和持久化存储。

### Q7: 如何处理集合中的空值？

**A:** 使用 `ofStream()` 方法创建流，然后内部会自动处理集合中的空值。

```java
List<String> names = Null.ofStream(users)
    .map(User::getName)
    .collect(Collectors.toList());
```

### Q10: 如何执行多个并发任务？

**A:** 使用 `NullGroupTask` 创建任务组，然后使用 `task()` 方法并发执行：

```java
NullGroupTask taskGroup = NullGroupTask.buildGroup(
    NullGroupTask.task(Task1.class.getName(), param1),
    NullGroupTask.task(Task2.class.getName(), param2)
);

Map<String, Object> results = Null.of(data)
    .task(taskGroup)
    .orElse(new HashMap<>());
```

## 总结

Null-Chain 是一个强大的空值安全链式编程框架，通过提供丰富的链式 API，可以优雅地处理可能为空的值，彻底避免 `NullPointerException`。

### 核心优势

1. **空值安全**：所有操作都是空值安全的
2. **链式调用**：代码更简洁易读
3. **类型安全**：通过泛型保证类型安全
4. **高性能**：延迟执行和短路操作
5. **功能丰富**：支持 HTTP、JSON、日期、计算等操作
6. **任务编排**：支持任务、工具、脚本的编排和并发执行
7. **易于集成**：完美集成 Spring Boot 和 Dubbo

### 适用场景

- API 接口返回值处理
- 数据库查询结果处理
- 配置文件读取
- 集合数据处理
- HTTP 请求处理
- 多级对象属性访问
- 条件过滤和转换
- 任务编排和并发执行

