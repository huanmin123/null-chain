# NF 脚本

本文档介绍 NF 脚本语言的使用方法。

## 概述

**NF 脚本**是框架提供的自定义脚本语言，用于执行动态逻辑。

**核心特点**：
- 支持变量定义和赋值（包括 `var` 自动类型推导）
- 支持条件判断（if/else、switch）
- 支持循环（for、while、do-while）
- 支持函数定义和调用（单/多返回值、可变参数、递归）
- 支持任务调用和并发执行
- 支持导入 Java 类型、任务和脚本文件
- 支持导出变量

## 快速开始

### 最简单的示例

```nf
// 定义变量
String name = "张三"
Integer age = 25

// 条件判断
if age >= 18 {
    echo "已成年"
}

// 循环
for i in 1..5 {
    echo "i = {i}"
}

// 导出结果
export "姓名: {name}, 年龄: {age}"
```

### 使用 var 自动类型推导

```nf
// 自动推导类型
var name = "李四"      // 推断为 String
var age = 30          // 推断为 Integer

// 手动指定类型
var count:Integer = 100
```

### 定义和调用函数

```nf
// 定义函数
fun add(int a, int b)Integer {
    return a + b
}

// 调用函数
Integer result = add(10, 20)
echo "10 + 20 = {result}"
```

## 基本语法

### 变量定义

**显式类型声明**

```nf
String name = "张三"
Integer age = 25
Double salary = 5000.50
Boolean isValid = true
```

**var 自动类型推导**

```nf
var name = "李四"           // 自动推断为 String
var age = 30               // 自动推断为 Integer
var salary = 8000.50       // 自动推断为 Double
```

**var 手动指定类型**

```nf
var name:String = "王五"
var age:Integer = 35
```

**new 关键字创建对象**

```nf
// 必须指定类型
var user:UserEntity = new
user.setName("huanmin")

// 带参数的构造函数
var list:ArrayList = new("item1", "item2")
```

**变量命名规则**
- 必须以字母或下划线开头
- **不能以 `$` 开头**（`$` 前缀保留给系统变量使用）
- 不能使用保留关键字（见文末关键字表）

**系统变量**（只读，以 `$` 开头）
- `$preValue` - 前一个任务的返回值
- `$params` - 参数集合
- `$threadFactoryName` - 线程池名称

### 数据类型

**基本类型**
- `String` - 字符串
- `Integer` - 整数
- `Double` / `Float` - 浮点数
- `Boolean` - 布尔值
- `Long` / `Short` / `Byte` - 其他整数类型
- `BigDecimal` - 高精度小数
- `Date` / `LocalDate` / `LocalDateTime` / `LocalTime` - 日期时间类型

**集合类型**
- `List` / `ArrayList` - 列表
- `Map` / `HashMap` - 键值对映射
- `Set` / `HashSet` - 集合
- `LinkedList` / `TreeMap` / `TreeSet` - 其他集合实现

**Java 类型导入**

NF 脚本支持导入任意 Java 类，包括：
- JDK 标准库中的类
- 第三方库中的类
- 自定义的业务类

```nf
// 导入任意 Java 类
import type java.util.UUID
import type java.io.File
import type com.example.User

// 使用导入的类
String id = UUID.randomUUID().toString()
File file = new
User user = new
```

**默认导入类型**

以下类型已默认导入，无需显式 import：
- 基本类型：`String`, `Integer`, `Long`, `Double`, `Float`, `Boolean`, `Object`
- 集合类型：`List`, `Map`, `Set`, `ArrayList`, `HashMap`, `HashSet`, `LinkedList`, `TreeMap`, `TreeSet`
- 并发集合：`ConcurrentHashMap`, `CopyOnWriteArrayList`
- 日期时间：`Date`, `LocalDate`, `LocalDateTime`, `LocalTime`, `DateTimeFormatter`, `DateFormatEnum`
- 空链工具：`Null`, `NullChain`, `NullCheck`, `NullCalculate`, `NullStream`, `OkHttp`
- 其他工具：`Objects`, `Arrays`, `Collections`, `UUID`, `Files`, `BigDecimal`

详细的默认导入类型列表请参考：**[NF 脚本默认导入类型](./14-NF脚本默认导入类型.md)**

**字符串和占位符**

```nf
// 普通字符串
String str = "hello"

// 模板字符串（支持占位符 {变量名}，支持多行）
var name = "张三"

var template = ``

姓名: {name}

年龄: 25

```

// 占位符在所有位置都支持
String result = "姓名: {name}, 年龄: {age}"
export "用户: {name}"
echo "值: {result}"
```

### 运算符

**算术运算符**
- `+` `-` `*` `/` `%` - 加、减、乘、除、取模

**比较运算符**
- `>` `<` `>=` `<=` - 大于、小于、大于等于、小于等于
- `==` `!=` - 等于、不等于

**逻辑运算符**
- `and` / `&&` - 逻辑与
- `or` / `||` - 逻辑或
- `!` - 逻辑非

**类型判断**
- `instanceof` - 判断对象类型（支持父子关系）

```nf
Object obj = "hello"
if obj instanceof String {
    echo "是字符串类型"
}
```

## 控制流

### 条件判断

**if/else**

```nf
if age >= 18 {
    echo "已成年"
} else {
    echo "未成年"
}

// 多重条件
if age < 18 {
    echo "未成年"
} else if age < 60 {
    echo "成年"
} else {
    echo "老年"
}
```

**switch**

```nf
switch month {
    case 1, 2, 3
        echo "第一季度"
    case 4, 5, 6
        echo "第二季度"
    default
        echo "其他季度"
}
```

**注意**：case 后面不带冒号，直接换行写语句。

### 循环

**for 范围循环**

```nf
// 1 到 10（包含边界值）
for i in 1..10 {
    echo "i = {i}"
}

// 使用变量作为范围
Integer start = 1
Integer end = 5
for i in start..end {
    echo "i = {i}"
}
```

**只支持整数类型**（Integer、Long、Short、Byte），不支持小数。

**for 集合迭代**

```nf
// 列表迭代 (包括Set)
ArrayList list = new
list.add("a")
list.add("b")
for item in list {
    echo "item = {item}"
}

// Map 迭代
Map map = new
map.put("key1", "value1")
map.put("key2", "value2")
for key, value in map {
    echo "key: {key}, value: {value}"
}
```

**while 循环**

```nf
Integer i = 0
while i < 5 {
    echo "i = {i}"
    i = i + 1
}
```

**do-while 循环**

```nf
Integer x = 0
do {
    echo "x = {x}"
    x = x + 1
} while x < 5
```

**循环控制**

```nf
for i in 1..10 {
    if i == 5 {
        break      // 跳出当前循环
    }
    if i == 3 {
        continue   // 跳过本次循环
    }
    echo "i = {i}"
}

// breakall - 跳出所有嵌套循环
for i in 1..5 {
    for j in 1..5 {
        if i * j == 6 {
            breakall   // 跳出所有循环
        }
    }
}
```

## 函数

### 函数定义

**基本语法**：`fun 函数名(参数列表)返回值类型列表 { 函数体 }`

```nf
// 单返回值函数
fun add(int a, int b)Integer {
    return a + b
}

// 多返回值函数
fun getUserInfo()String, Integer {
    return "张三", 25
}

// 调用多返回值函数
var name, age = getUserInfo()
```

**可变参数函数**

```nf
fun sum(int... values)Integer {
    Integer total = 0
    for v in values {
        total = total + v
    }
    return total
}

Integer result = sum(1, 2, 3, 4, 5)
```

**递归函数**

```nf
fun factorial(int n)Integer {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

Integer fact = factorial(5)
```

### 函数调用

```nf
// 调用当前脚本的函数
Integer result = add(10, 20)

// 调用导入脚本的函数
String data = myscript.processData("input")

// 函数调用在表达式中
Integer value = add(5, 10) * 2
```

## 作用域

### 作用域类型

| 作用域类型 | 说明 | 创建时机 |
|-----------|------|----------|
| **全局作用域 (ALL)** | 脚本的主作用域和函数体作用域 | 脚本开始执行时创建全局作用域；函数调用时创建函数作用域 |
| **if 作用域 (IF)** | if 语句的代码块 | 进入 if/else 代码块时创建 |
| **switch 作用域 (SWITCH)** | switch 语句的 case 分支 | 进入 switch 语句时创建 |
| **循环作用域 (FOR)** | for/while/do-while 循环体 | 进入循环体时创建 |

### 变量可见性规则

```nf
// 全局变量 - 在整个脚本中可见
String globalVar = "全局变量"

fun testScope()String {
    // 函数内变量 - 只在函数体内可见
    String localVar = "局部变量"

    // 可以访问全局变量
    echo globalVar  // ✓ 可访问

    return localVar
}

// 函数外无法访问函数内的局部变量
// echo localVar  // ✗ 编译错误

if true {
    // if 作用域变量 - 只在 if 代码块内可见
    String ifVar = "if作用域"

    // 可以访问外层作用域的变量
    echo globalVar  // ✓ 可访问

    // 修改外层变量
    globalVar = "已修改"
}

// if 作用域结束后，ifVar 不可访问
// echo ifVar  // ✗ 编译错误
```

### 变量遮蔽规则

**允许遮蔽的情况**
- ✅ 函数内变量可以遮蔽全局变量
- ✅ 函数参数可以遮蔽全局变量

**不允许遮蔽的情况**
- ❌ if/for/while/do-while 块内变量不能与外层同名（会报重复声明错误）

```nf
// ✓ 允许：函数内变量遮蔽全局变量
Integer x = 100

fun testFunction()Integer {
    Integer x = 200  // 遮蔽全局 x
    return x
}

// ✗ 错误：if 块内变量与外部同名
Integer outer = 100
if true {
    // Integer outer = 200  // ❌ 错误：outer 在外部作用域已声明
    Integer inner = 200    // ✅ 正确：使用不同的变量名
}
```

### 使用 global 访问被遮蔽的全局变量

当局部变量遮蔽了全局变量时，使用 `global.变量名` 访问全局变量。

```nf
Integer x = 100  // 全局变量

fun test(int x)Integer {
    // 参数 x 遮蔽了全局 x
    // 使用 global.x 访问全局的 x
    return x + global.x  // 50 + 100 = 150
}

Integer result = test(50)
echo "result = {result}"  // 输出：150
```

**使用场景**
- 函数参数与全局变量同名时
- 函数内定义了与全局变量同名的局部变量时

### 循环作用域的特殊性

```nf
// for 循环：每次迭代创建新作用域
for i in 1..3 {
    Integer value = i * 10
    // 每次迭代，value 都是新变量
}

// while 循环：整个循环共享一个作用域
Integer j = 0
while j < 3 {
    Integer value = j * 10
    // value 在整个 while 循环中是同一个变量
    j = j + 1
}

// do-while 循环：与 while 类似，共享一个作用域
Integer k = 0
do {
    Integer value = k * 10
    k = k + 1
} while k < 3
```

## 导入和导出

### 导入类型和任务

```nf
// 导入 Java 类型
import type com.example.UserEntity

// 导入任务，起别名
import task com.example.Test1Task as test1
import task com.example.Test2Task as test2
```

**命名冲突规则**
- 类型导入名称不能与已导入的任务名称或 NF 脚本名称冲突
- 任务导入名称不能与已导入的类型名称或 NF 脚本名称冲突
- 如果名称冲突，可以使用 `as` 关键字指定别名来避免冲突
- 系统会在导入时检测冲突并抛出异常提示

### 调用 Java 类和方法

NF 脚本支持调用任意 Java 类和方法，包括静态方法、实例方法和构造函数。

**调用静态方法**

```nf
// 导入工具类
import type java.util.UUID
import type java.lang.Math

// 调用静态方法
String id = UUID.randomUUID().toString()
Double maxValue = Math.max(10.5, 20.3)

// 链式调用
String result = UUID.randomUUID().toString().toUpperCase()
```

**创建对象和调用实例方法**

```nf
// 导入类
import type java.util.ArrayList
import type java.util.HashMap

// 创建对象（使用 new 关键字）
ArrayList list = new
HashMap map = new

// 调用实例方法
list.add("Hello")
list.add("World")
Integer size = list.size()

map.put("name", "张三")
map.put("age", 25)
String name = map.get("name")
```

**使用默认导入的类型**

NF 脚本默认已导入常用类型，无需显式导入：

```nf
// 基本类型已默认导入
String str = "Hello"
Integer num = 100
List list = new
Map map = new
ArrayList arrList = new
HashMap hashMap = new

// 数学工具
Integer max = Math.max(10, 20)
Double sqrt = Math.sqrt(16.0)

// 字符串处理
StringBuilder sb = new
sb.append("Hello").append(" World")

// 系统工具
Long time = System.currentTimeMillis()

// 随机数
Random rand = new
Integer randomNum = rand.nextInt(100)

// 文件操作
File file = new("/path/to/file.txt")
Boolean exists = file.exists()
```

**自定义类型导入**

```nf
// 导入自定义实体类
import type com.example.User
import type com.example.Order as Ord

// 使用自定义类型
User user = new
user.setName("张三")
user.setAge(25)

Order order = new
order.setUserId(1001)
```

**类型转换和判断**

```nf
// 使用 instanceof 判断类型
import type java.util.ArrayList
import type java.util.List

List list = new
if list instanceof ArrayList {
    echo "这是一个 ArrayList"
}

// 使用类型转换
Object obj = "Hello String"
if obj instanceof String {
    String str = obj
    echo str.length()
}
```

### 导入 NF 脚本

**语法**：`import nf 脚本名称1, 脚本名称2` 或 `import nf 脚本名称 as 别名`

```nf
// 导入单个脚本（使用原始名称）
import nf utils

// 调用导入脚本的函数
String result = utils.formatUser("张三", 25)

// 导入多个脚本（逗号分隔）
import nf math, string, config

// 使用 as 别名（避免命名冲突）
import nf utils as util
import nf math as m
import nf string as str

// 使用别名调用
String formatted = str.toUpperCase("hello")
Integer sum = m.add(10, 20)

// 混合使用
import nf math as m, string, config as cfg
```

**命名冲突规则**
- 脚本导入别名不能与已导入的类型名称冲突
- 脚本导入别名不能与已导入的任务名称冲突
- 如果名称冲突，可以使用 `as` 指定不同的别名来避免冲突
- 系统会在导入时检测冲突并抛出异常提示

**使用场景**
- 将常用函数定义在工具脚本中（如 `math.nf`、`string.nf`）
- 在多个脚本中复用这些函数
- 通过 `别名.函数名()` 的方式调用
- 脚本需要提前加载,然后起一个唯一名称之后才能在其他脚本中调用
- 使用别名避免命名冲突

### 调用任务

```nf
// 调用任务
run test1(a, b)

// 调用任务并绑定变量
run test1(a, b) -> result:String

// 多任务并发执行
run test1(a, b), test2(a, b) -> results:Map
```

### 导出变量

```nf
// 导出变量
export result

// 导出表达式结果
export a + b

// 导出模板字符串
export "姓名: {name}, 年龄: {age}"
```

## 关键字速查表

以下为 NF 脚本的保留关键字，不能用作变量名：

| 分类 | 关键字 |
|------|--------|
| 导入相关 | `import`, `type`, `task`, `as` |
| 控制流 | `if`, `else`, `switch`, `case`, `default`, `while`, `do`, `for`, `in` |
| 循环控制 | `break`, `breakall`, `continue` |
| 函数相关 | `fun`, `return` |
| 执行相关 | `run`, `export`, `echo` |
| 变量声明 | `var` |
| 全局变量访问 | `global` |
| 逻辑运算符 | `and`, `or` |
| 布尔常量 | `true`, `false` |
| 对象创建 | `new` |
| 类型判断 | `instanceof` |
| 其他 | `this` |

## Java 集成

### 执行脚本文件

```java
String filePath = "path/to/script.nf";
Object result = Null.of(input)
    .nfTask(NullGroupNfTask.taskFile(filePath))
    .orElse(null);
```

### 执行脚本内容

```java
String script = "String a = '123'; run test1(a) -> result:String; export result";
Object result = Null.of(input)
    .nfTask(script, param1, param2)
    .orElse(null);
```

### 并发执行脚本组

```java
NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
    NullGroupNfTask.task("run task1(input) -> result1:String; export result1"),
    NullGroupNfTask.task("run task2(input) -> result2:String; export result2"),
    NullGroupNfTask.taskFile("scripts/task3.nf")
);

Map<String, Object> results = Null.of(input)
    .nfTasks(nfTaskGroup, "customThreadPool")
    .orElse(new HashMap<>());
```

## 注意事项

1. **类型安全**：脚本中的类型需要与 Java 类型匹配
2. **任务注册**：任务需要先注册才能被脚本调用
3. **变量重复**：if/for/while/do-while 块内变量不能与外层同名（会报重复声明错误）
4. **函数遮蔽**：函数内变量可以遮蔽全局变量，使用 `global.变量名` 访问被遮蔽的全局变量
5. **Java 类型导入**：
   - 可以导入任意 Java 类（包括 JDK、第三方库、自定义类）
   - 导入后可以直接调用静态方法、实例方法和构造函数
   - 常用类型已默认导入，无需显式 import
   - 使用 `import type 完整类名` 导入，支持 `as` 别名避免命名冲突
6. **导入命名冲突**：
   - 类型、任务、NF 脚本的导入名称不能重复
   - 可以使用 `as` 关键字指定别名避免冲突
   - 系统会在导入时检测冲突并抛出异常
7. **并发执行**：脚本组可以并发执行，但需要注意线程安全
8. **性能考虑**：脚本是运行时执行的，性能可能略低于直接调用任务
9. **错误处理**：脚本执行错误会抛出异常，需要自行处理
10. **Lambda 表达式不支持**：
    - NF 脚本**不支持** Java 8 的 Lambda 表达式语法
    - 如果方法入参是接口类型（如 `Consumer<T>`、`Function<T,R>`、`Predicate<T>` 等），需要先实现一个具体的类，然后通过对象的方式传入
    - **错误示例**：
      ```nf
      // ✗ 不支持 Lambda 表达式
      list.forEach(item -> echo item)
      ```
    - **正确做法**：
      ```nf
      // 1. 先在 Java 代码中实现接口
      public class PrintConsumer implements Consumer<String> {
          @Override
          public void accept(String item) {
              System.out.println(item);
          }
      }

      // 2. 在 NF 脚本中导入并使用对象
      import type com.example.PrintConsumer

      PrintConsumer printer = new
      list.forEach(printer)  // 传入对象而非 Lambda
      ```

## 使用场景

1. **动态配置**：通过脚本实现动态逻辑，无需重新编译
2. **业务规则**：将业务规则编写为脚本，便于修改和维护
3. **工作流编排**：通过脚本编排多个任务的执行流程
4. **A/B 测试**：通过脚本实现不同的业务逻辑分支
5. **函数复用**：定义常用函数，在脚本中重复调用
6. **复杂计算**：使用函数和循环实现复杂的业务逻辑

## 附录

- **[NF 脚本默认导入类型](./14-NF脚本默认导入类型.md)** - 完整的默认导入类型列表和使用说明
