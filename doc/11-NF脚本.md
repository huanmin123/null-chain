# NF脚本

本文档介绍 NF 脚本语言的使用方法，用于执行动态逻辑。

## 概述

**NF 脚本**是框架提供的自定义脚本语言，用于执行动态逻辑。

**特点**：
- 支持变量定义和赋值（包括 var 自动类型推导）
- 支持条件判断（if/else、switch）
- 支持循环（for、while、do-while）
- 支持函数定义和调用（包括多返回值和可变参数）
- 支持任务调用
- 支持并发任务执行
- 支持导入 Java 类型和任务
- 支持导入其他脚本文件
- 支持导出变量

## 基本语法

### 变量定义

**方式一：显式类型声明**

```nf
// 定义变量（声明并赋值）
String a = "123"
Integer b = 123
UserEntity user = new
user.setName("huanmin")

// 只声明不赋值
Integer a
String b
```

**方式二：var 自动类型推导**

```nf
// 自动类型推导（编译器根据赋值表达式推断类型）
var name = "张三"           // 推断为 String
var age = 25               // 推断为 Integer
var salary = 5000.50       // 推断为 Double
var isMarried = false      // 推断为 Boolean

// 手动指定类型（冒号后跟类型）
var name:String = "李四"
var age:Integer = 30

// new 关键字创建对象（必须指定类型）
var user:UserEntity = new
user.setName("huanmin")

// 带参数的构造函数调用
var list:ArrayList = new("item1", "item2", "item3")
```

**var 与多返回值函数调用**

```nf
// 定义多返回值函数
fun getUserInfo()String, Integer {
    return "张三", 25
}

// 全部自动推导
var name, age = getUserInfo()

// 混合类型声明（部分指定类型）
var name, age:Integer = getUserInfo()  // name自动推导，age指定为Integer
var name:String, age = getUserInfo()   // name指定为String，age自动推导

// 全部指定类型
var name:String, age:Integer = getUserInfo()
```

**变量命名规则**：
- 必须以字母或下划线开头
- 支持字母、数字、下划线的组合
- **不能以 `$` 开头**（`$` 前缀保留给系统变量使用）
- 不能使用保留关键字

**系统变量**（以 `$` 开头）：
- `$preValue` - 前一个任务的返回值
- `$params` - 参数集合
- `$threadFactoryName` - 线程池名称
- `$$nextTaskValue$$` - 导出值（export 的值）

### 字符串

**普通字符串**：使用双引号 `""`
```nf
String a = "123"
String b = "hello"
```

**模板字符串**：使用三个反引号 `` ``` ``，支持占位符 `{变量名}`，支持多行换行

String name = "world"

String message = `` ``` ``

Hello {name}

`` ``` ``  
// message = "Hello world"


// 多个占位符
Integer age = 18

String info = `` ``` `` 

Name: {name}, Age: {age}

`` ``` ``  

// info = "Name: world, Age: 18"



### 导入类型和任务

```nf
// 导入 Java 类型
import type com.example.UserEntity

// 导入任务，起别名
import task com.example.Test1Task as test1
import task com.example.Test2Task as test2

// 导入其他脚本文件
import type com.example.script.MyScript as myscript
```

### 调用任务

```nf
// 调用任务
run test1(a, b)

// 调用任务并绑定变量
run test1(a, b) -> result:String

// 多任务并发执行
run test1(a, b), test2(a, b) -> results:Map
```

### 条件判断

```nf
// if/else
if b > 100 {
    echo "b 大于 100"
} else {
    echo "b 小于等于 100"
}

// switch（注意：case 后面不带冒号，直接换行写语句）
switch b {
    case 100
        echo "b 等于 100"
    case 200
        echo "b 等于 200"
    default
        echo "b 是其他值"
}

// 多值匹配（用逗号分隔）
switch month {
    case 1, 2, 3
        echo "第一季度"
    case 4, 5, 6
        echo "第二季度"
    default
        echo "其他季度"
}
```

### 作用域

**作用域类型**

NF 脚本支持以下几种作用域类型：

| 作用域类型 | 说明 | 创建时机 |
|-----------|------|----------|
| **全局作用域 (ALL)** | 脚本的主作用域和函数体作用域 | 脚本开始执行时创建全局作用域；函数调用时创建函数作用域 |
| **if 作用域 (IF)** | if 语句的代码块 | 进入 if/else 代码块时创建 |
| **switch 作用域 (SWITCH)** | switch 语句的 case 分支 | 进入 switch 语句时创建 |
| **循环作用域 (FOR)** | for/while/do-while 循环体 | 进入循环体时创建 |

**变量可见性规则**

```nf
// 全局作用域变量 - 在整个脚本中可见
String globalVar = "全局变量"

fun testScope()String {
    // 函数作用域变量 - 只在函数体内可见
    String localVar = "局部变量"

    // 可以访问全局变量
    echo globalVar  // ✓ 可访问

    return localVar
}

// 在函数外无法访问函数内的局部变量
// echo localVar  // ✗ 编译错误：变量不存在

if true {
    // if 作用域变量 - 只在 if 代码块内可见
    String ifVar = "if作用域"

    // 可以访问外层作用域的变量
    echo globalVar  // ✓ 可访问全局变量

    // 修改外层变量
    globalVar = "已修改"
}

// if 作用域结束后，ifVar 不可访问
// echo ifVar  // ✗ 编译错误

// 可以访问被修改的全局变量
echo globalVar  // 输出：已修改

for i in 1..5 {
    // 循环作用域变量
    Integer loopVar = i * 10

    // 每次迭代都会创建新的循环作用域
    echo "loopVar: {loopVar}"
}

// 循环作用域结束后，loopVar 不可访问
// echo loopVar  // ✗ 编译错误

// 但循环变量 i 在循环作用域中定义
// 每次迭代都会更新 i 的值
```

**作用域嵌套和变量遮蔽**

```nf
String name = "全局name"

fun testShadow()String {
    String name = "函数name"  // 遮蔽全局变量

    echo name  // 输出：函数name

    if true {
        String name = "if作用域name"  // 再次遮蔽
        echo name  // 输出：if作用域name
    }

    echo name  // 输出：函数name（if作用域结束）

    return name
}

echo name  // 输出：全局name（函数作用域不影响全局）
```

**循环作用域的特殊性**

```nf
// for 循环：每次迭代创建新作用域
for i in 1..3 {
    Integer value = i * 10
    echo "i={i}, value={value}"
    // 每次迭代，value 都是新变量
}

// while 循环：整个循环共享一个作用域
Integer j = 0
while j < 3 {
    Integer value = j * 10
    echo "j={j}, value={value}"
    j = j + 1
    // value 在整个 while 循环中是同一个变量
}

// do-while 循环：与 while 类似，共享一个作用域
Integer k = 0
do {
    Integer value = k * 10
    echo "k={k}, value={value}"
    k = k + 1
} while k < 3
```

**函数作用域**

```nf
// 全局变量
String result = ""

fun process(String input)String {
    // 函数作用域变量
    String temp = input.toUpperCase()

    // 可以访问全局变量
    result = temp

    // return 语句可以访问函数作用域内的所有变量
    return temp
}

// 调用函数
String output = process("hello")

// 函数执行后，函数内的局部变量不可访问
// echo temp  // ✗ 编译错误

// 但函数修改的全局变量会保留
echo result  // 输出：HELLO
```

**脚本导入的作用域**

```nf
// 导入其他脚本
import type com.example.script.MyScript as myscript

// 当前脚本的变量
String localVar = "当前脚本变量"

// 可以调用导入脚本的函数
String data = myscript.getData()

// 访问导入脚本的全局变量（需要脚本导出）
// var importedValue = myscript.exportedVar
```

**作用域生命周期**

```nf
// ========== 全局作用域开始 ==========
String globalVar = "全局"

fun lifecycle()String {
    // ========== 函数作用域开始 ==========
    String funcVar = "函数"

    if true {
        // ========== if 作用域开始 ==========
        String ifVar = "if"
        // 可以访问：ifVar, funcVar, globalVar
        // ========== if 作用域结束 ==========
    }
    // ifVar 已销毁，不可访问
    // 可以访问：funcVar, globalVar

    for i in 1..3 {
        // ========== 循环作用域开始 ==========
        String loopVar = "循环"
        // 可以访问：loopVar, funcVar, globalVar
        // ========== 循环作用域结束 ==========
    }
    // loopVar 已销毁，不可访问

    return funcVar
    // ========== 函数作用域结束 ==========
}
// funcVar 已销毁，不可访问
// ========== 全局作用域结束 ==========
```

### 函数定义

**基本语法**：`fun 函数名(参数列表)返回值类型列表 { 函数体 }`

```nf
// 单返回值函数
fun add(int a, int b)Integer {
    return a + b
}

// 多返回值函数（返回值类型用逗号分隔）
fun getUserInfo()String, Integer {
    String name = "张三"
    Integer age = 25
    return name, age
}

// 调用多返回值函数
var userName, userAge = getUserInfo()
echo "姓名:{userName}, 年龄:{userAge}"

// 可变参数函数（使用 ... 表示可变参数）
fun sum(int... values)Integer {
    Integer total = 0
    for v in values {
        total = total + v
    }
    return total
}

// 调用可变参数函数
Integer result = sum(1, 2, 3, 4, 5)
echo "1+2+3+4+5 = {result}"

// 递归函数
fun factorial(int n)Integer {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

Integer fact = factorial(5)
echo "5! = {fact}"
```

**函数调用**

```nf
// 调用当前脚本中定义的函数
Integer result = add(10, 20)
echo "add(10, 20) = {result}"

// 调用导入脚本的函数（使用 脚本名.函数名）
String data = myscript.processData("input")

// 函数调用在表达式中
Integer value = add(5, 10) * 2
echo "(5 + 10) * 2 = {value}"
```

### 循环

**for 范围循环**：`for 变量名 in 起始值..结束值 { ... }`
- 起始值和结束值可以是整数字面量（如 `1..10`）或整数类型变量
- **只支持整数类型**（Integer、Long、Short、Byte），不支持小数
- 循环变量从起始值递增到结束值（包含边界值）

**for 集合迭代**：`for item in 集合变量 { ... }` 或 `for key, value in Map变量 { ... }`
- 支持 List、Set、Map、数组类型

**while 循环**：`while 条件 { ... }`
- 先判断条件，再执行循环体

**do-while 循环**：`do { ... } while 条件`
- 先执行一次循环体，再判断条件
- 保证循环体至少执行一次

**循环控制**：
- `break` - 跳出当前循环
- `continue` - 跳过本次循环
- `breakall` - 跳出所有嵌套循环

```nf
// for 范围循环（常量范围）
for i in 1..10 {
    echo "value:{i}"
}

// for 动态范围循环（变量作为范围值）
Integer start = 1
Integer end = 5
Integer sum = 0
for i in start..end {
    sum = sum + i
}
// sum = 15 (1+2+3+4+5)

// for 动态范围支持计算后的变量
Integer base = 10
Integer offset = 5
Integer start2 = base - offset  // 5
Integer end2 = base + offset    // 15
for i in start2..end2 {
    echo "i:{i}"
}
// 循环从 5 到 15

// for 列表迭代
ArrayList list = new
list.add("a")
list.add("b")
for item in list {
    echo "item:{item}"
}

// for Map 迭代
Map map = new
map.put("key1", "value1")
map.put("key2", "value2")
for key, value in map {
    echo "key:{key}, value:{value}"
}

// for Set 迭代
HashSet set = new
set.add(1)
set.add(2)
for item in set {
    echo "item:{item}"
}

// while 循环
Integer i = 0
while i < 5 {
    echo "i:{i}"
    i = i + 1
}

// do-while 循环（至少执行一次）
Integer x = 0
do {
    echo "x:{x}"
    x = x + 1
} while x < 5

// do-while 循环（条件不满足也会执行一次）
Integer y = 10
do {
    echo "y:{y}  (只会执行一次)"
    y = y + 1
} while y < 5

// 循环控制
for i in 1..10 {
    if i == 5 {
        break      // 跳出当前循环
    }
    if i == 3 {
        continue   // 跳过本次循环
    }
    echo "i:{i}"
}

// breakall - 跳出所有嵌套循环
for i in 1..5 {
    for j in 1..5 {
        if i * j == 6 {
            breakall   // 跳出所有循环
        }
    }
}
```

### 运算符

```nf
// 算术运算符
+ - * / %     // 加、减、乘、除、取模

// 比较运算符
> < >= <=     // 大于、小于、大于等于、小于等于
== !=        // 等于、不等于

// 逻辑运算符
and / &&     // 逻辑与
or / ||      // 逻辑或
!            // 逻辑非

// 示例
if a > 10 and b < 20 {
    echo "a > 10 且 b < 20"
}

if a == 10 or b == 20 {
    echo "a == 10 或 b == 20"
}

// 也可以使用 && 和 ||
if a > 10 && b < 20 {
    echo "a > 10 且 b < 20"
}
```

### 类型判断

```nf
// instanceof - 判断对象类型（支持父子关系）
Object obj = "hello"
if obj instanceof String {
    echo "obj 是字符串类型"
}

// 支持精确类型匹配
ArrayList list = new
if list instanceof ArrayList {
    echo "list 是 ArrayList 类型"
}

// 支持父类/接口匹配（子类 instanceof 父类 返回 true）
Object obj2 = list
if obj2 instanceof Object {
    echo "obj2 是 Object 类型（父类匹配）"
}

// 支持全限定名类型
if obj2 instanceof java.util.List {
    echo "obj2 是 java.util.List 接口的实现类"
}
```

### 布尔值

```nf
// 布尔常量
Boolean flag1 = true
Boolean flag2 = false

if flag1 and !flag2 {
    echo "flag1 为 true 且 flag2 为 false"
}
```

### 关键字

以下为 NF 脚本的保留关键字，不能用作变量名：

| 分类 | 关键字 |
|------|--------|
| 导入相关 | `import`, `type`, `task`, `as` |
| 控制流 | `if`, `else`, `switch`, `case`, `default`, `while`, `do`, `for`, `in` |
| 循环控制 | `break`, `breakall`, `continue` |
| 函数相关 | `fun`, `return` |
| 执行相关 | `run`, `export`, `echo` |
| 变量声明 | `var` |
| 逻辑运算符 | `and`, `or` |
| 布尔常量 | `true`, `false` |
| 对象创建 | `new` |
| 类型判断 | `instanceof` |
| 其他 | `this` |

### 导出变量

```nf
// 导出变量
export result

// 导出表达式结果
export a + b

// 导出模板字符串
export "result:{result}"
```

## 执行 NF 脚本

### 执行脚本文件

```java
// 执行 NF 脚本文件
String filePath = "path/to/script.nf";
Object result = Null.of(input)
    .nfTask(NullGroupNfTask.taskFile(filePath))
    .orElse(null);
```

### 执行脚本内容

```java
// 执行 NF 脚本内容
String script = "String a = '123'; run test1(a) -> result:String; export result";
Object result = Null.of(input)
    .nfTask(script, param1, param2)
    .orElse(null);
```

### 使用指定线程池

```java
// 使用指定线程池执行脚本
Object result = Null.of(input)
    .nfTask(script, "customThreadPool", param1, param2)
    .orElse(null);
```

## NF 脚本组并发执行

### 创建脚本组

```java
import com.gitee.huanminabc.nullchain.common.NullGroupNfTask;

// 创建 NF 脚本组
NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
    NullGroupNfTask.task("String a = '123'; run test1(a) -> result:String; export result"),
    NullGroupNfTask.taskFile("path/to/script2.nf")
);
```

### 并发执行脚本组

```java
// 并发执行 NF 脚本组
Map<String, Object> results = Null.of(input)
    .nfTasks(nfTaskGroup, "customThreadPool")
    .orElse(new HashMap<>());
```

## 完整示例

### 脚本文件示例（script.nf）

```nf
// ============================================
// NF 脚本完整示例
// ============================================

// 导入 Java 类型
import type com.example.UserEntity

// 导入任务
import task com.example.UserValidationTask as validate
import task com.example.UserProcessingTask as process

// ========== 函数定义示例 ==========

// 定义加法函数
fun add(int a, int b)Integer {
    return a + b
}

// 定义多返回值函数
fun analyzeUser(String name, Integer age)String, String, Boolean {
    String level = ""
    Boolean isValid = false

    if age < 18 {
        level = "未成年"
    } else if age < 30 {
        level = "青年"
    } else if age < 50 {
        level = "中年"
    } else {
        level = "老年"
    }

    if age >= 18 && age <= 60 {
        isValid = true
    }

    return name, level, isValid
}

// 定义可变参数函数
fun sum(int... values)Integer {
    Integer total = 0
    for v in values {
        total = total + v
    }
    return total
}

// ========== 主程序逻辑 ==========

// 使用 var 自动类型推导定义变量
var userName = "张三"
var userAge = 25

// 调用函数
var name, level, isValid = analyzeUser(userName, userAge)
echo "姓名: {name}"
echo "级别: {level}"
echo "是否有效: {isValid}"

// 使用 do-while 循环
Integer count = 0
Integer sumResult = 0
do {
    sumResult = sumResult + count
    count = count + 1
} while count <= 10
echo "1到10的和（do-while）: {sumResult}"

// 使用 while 循环
Integer i = 0
Integer whileSum = 0
while i <= 10 {
    whileSum = whileSum + i
    i = i + 1
}
echo "1到10的和（while）: {whileSum}"

// 调用可变参数函数
Integer total = sum(1, 2, 3, 4, 5)
echo "1+2+3+4+5 = {total}"

// ========== 任务调用示例 ==========

String userId = "123"
var user:UserEntity = new
user.setId(userId)

// 调用任务
run validate(user) -> isValid:Boolean

// 条件判断
if isValid {
    run process(user) -> processed:UserEntity

    // 使用函数处理结果
    var resultName, resultLevel, resultValid = analyzeUser(
        processed.getName(),
        processed.getAge()
    )

    export ```
处理成功:
姓名: {resultName}
级别: {resultLevel}
状态: {resultValid ? "有效" : "无效"}
```
} else {
    echo "用户验证失败"
    export null
}
```

### Java 代码示例

```java
public class NfScriptExample {

    public void executeScriptFile() {
        // 执行脚本文件
        String filePath = "scripts/user-process.nf";
        Object result = Null.of(input)
            .nfTask(NullGroupNfTask.taskFile(filePath))
            .orElse(null);
    }

    public void executeScriptContent() {
        // 执行脚本内容（使用新语法）
        String script =
            "fun add(int a, int b)Integer { " +
            "    return a + b " +
            "} " +
            "var result = add(10, 20) " +
            "echo '10 + 20 = {result}' " +
            "export result";

        Object result = Null.of(input)
            .nfTask(script, param1, param2)
            .orElse(null);
    }

    public void executeScriptGroup() {
        // 创建脚本组
        NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
            NullGroupNfTask.task(
                "fun process(String input)String { " +
                "    return input.toUpperCase() " +
                "} " +
                "var output = process('hello') " +
                "export output"
            ),
            NullGroupNfTask.task(
                "var sum = 0 " +
                "for i in 1..100 { " +
                "    sum = sum + i " +
                "} " +
                "export sum"
            ),
            NullGroupNfTask.taskFile("scripts/task3.nf")
        );

        // 并发执行脚本组
        Map<String, Object> results = Null.of(input)
            .nfTasks(nfTaskGroup, "customThreadPool")
            .orElse(new HashMap<>());
    }

    public void executeComplexScript() {
        // 执行复杂脚本（包含 do-while、函数定义、多返回值等）
        String script =
            "// 定义多返回值函数 " +
            "fun getUserInfo()String, Integer, Boolean { " +
            "    String name = '张三' " +
            "    Integer age = 25 " +
            "    Boolean isValid = true " +
            "    return name, age, isValid " +
            "} " +
            "" +
            "// 调用多返回值函数 " +
            "var userName, userAge, isValid = getUserInfo() " +
            "" +
            "// 使用 do-while 循环 " +
            "var count = 0 " +
            "do { " +
            "    echo 'Count: {count}' " +
            "    count = count + 1 " +
            "} while count < 5 " +
            "" +
            "// 导出结果 " +
            "export ''' " +
            "用户信息: " +
            "姓名: {userName} " +
            "年龄: {userAge} " +
            "状态: {isValid ? '有效' : '无效'} " +
            "'''";

        Object result = Null.of(input)
            .nfTask(script)
            .orElse(null);
    }
}
```

## 注意事项

1. **类型安全**：脚本中的类型需要与 Java 类型匹配
2. **任务注册**：任务需要先注册才能被脚本调用
4. **并发执行**：脚本组可以并发执行，但需要注意线程安全
5. **性能考虑**：脚本是运行时执行的，性能可能略低于直接调用任务
6. **错误处理**：脚本执行错误会抛出异常，需要自行处理

## 与任务/工具的区别

- **任务/工具**：使用 Java 代码实现，编译期检查，性能更好
- **NF 脚本**：使用脚本语言实现，运行时执行，更灵活但性能略低

## 使用场景

1. **动态配置**：通过脚本实现动态逻辑，无需重新编译
2. **业务规则**：将业务规则编写为脚本，便于修改和维护
3. **工作流编排**：通过脚本编排多个任务的执行流程
4. **A/B 测试**：通过脚本实现不同的业务逻辑分支
5. **函数复用**：定义常用函数，在脚本中重复调用
6. **复杂计算**：使用函数和循环实现复杂的业务逻辑

## 新增语法特性（v1.1.4+）

### 1. 函数定义和调用
- 支持定义自定义函数（`fun` 关键字）
- 支持单返回值和多返回值函数
- 支持可变参数函数（使用 `...`）
- 支持递归函数调用
- 支持调用导入脚本中的函数

### 2. var 变量声明
- 支持自动类型推导（根据赋值表达式推断类型）
- 支持手动指定类型（使用冒号语法）
- 支持与 new 关键字结合使用（必须指定类型）
- 支持与多返回值函数结合使用

### 3. do-while 循环
- 支持先执行后判断的循环结构
- 保证循环体至少执行一次

### 4. return 语句
- 支持单返回值
- 支持多返回值（用逗号分隔）
- 可在函数体任何位置返回

