# NF脚本

本文档介绍 NF 脚本语言的使用方法，用于执行动态逻辑。

## 概述

**NF 脚本**是框架提供的自定义脚本语言，用于执行动态逻辑。

**特点**：
- 支持变量定义和赋值
- 支持条件判断（if/else、switch）
- 支持循环（for）
- 支持任务调用
- 支持并发任务执行
- 支持导入 Java 类型和任务
- 支持导出变量

## 基本语法

### 变量定义

```nf
// 定义变量
String a = "123"
Integer b = 123
UserEntity user = new
user.setName("huanmin")
```

### 导入类型和任务

```nf
// 导入 Java 类型
import com.example.UserEntity

// 导入任务，起别名
task com.example.Test1Task as test1
task com.example.Test2Task as test2
```

### 调用任务

```nf
// 调用任务
run test1(a, b)

// 调用任务并绑定变量
run test1(a, b) -> result:String

// 多任务并发执行
run test1(a, b), test2(a, b) -> results:Map
```

### 条件判断

```nf
// if/else
if b > 100 {
    echo "b 大于 100"
} else {
    echo "b 小于等于 100"
}

// switch
switch b {
    case 100:
        echo "b 等于 100"
    case 200:
        echo "b 等于 200"
    default:
        echo "b 是其他值"
}
```

### 循环

```nf
// for 循环
for i in 1..10 {
    echo "value:{i}"
}

```

### 导出变量

```nf
// 导出变量
export result
```

## 执行 NF 脚本

### 执行脚本文件

```java
// 执行 NF 脚本文件
String filePath = "path/to/script.nf";
Object result = Null.of(input)
    .nfTask(NullGroupNfTask.taskFile(filePath))
    .orElse(null);
```

### 执行脚本内容

```java
// 执行 NF 脚本内容
String script = "String a = '123'; run test1(a) -> result:String; export result";
Object result = Null.of(input)
    .nfTask(script, param1, param2)
    .orElse(null);
```

### 使用指定线程池

```java
// 使用指定线程池执行脚本
Object result = Null.of(input)
    .nfTask(script, "customThreadPool", param1, param2)
    .orElse(null);
```

## NF 脚本组并发执行

### 创建脚本组

```java
import com.gitee.huanminabc.nullchain.common.NullGroupNfTask;

// 创建 NF 脚本组
NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
    NullGroupNfTask.task("String a = '123'; run test1(a) -> result:String; export result"),
    NullGroupNfTask.taskFile("path/to/script2.nf")
);
```

### 并发执行脚本组

```java
// 并发执行 NF 脚本组
Map<String, Object> results = Null.of(input)
    .nfTasks(nfTaskGroup, "customThreadPool")
    .orElse(new HashMap<>());
```

## 完整示例

### 脚本文件示例（script.nf）

```nf
// 导入 Java 类型
import com.example.UserEntity

// 导入任务
task com.example.UserValidationTask as validate
task com.example.UserProcessingTask as process

// 定义变量
String userId = "123"
UserEntity user = new
user.setId(userId)

// 调用任务
run validate(user) -> isValid:Boolean

// 条件判断
if isValid {
    run process(user) -> processed:UserEntity
    export processed
} else {
    echo "用户验证失败"
    export null
}
```

### Java 代码示例

```java
public class NfScriptExample {
    
    public void executeScriptFile() {
        // 执行脚本文件
        String filePath = "scripts/user-process.nf";
        Object result = Null.of(input)
            .nfTask(NullGroupNfTask.taskFile(filePath))
            .orElse(null);
    }
    
    public void executeScriptContent() {
        // 执行脚本内容
        String script = "String a = '123'; " +
                       "run test1(a) -> result:String; " +
                       "export result";
        Object result = Null.of(input)
            .nfTask(script, param1, param2)
            .orElse(null);
    }
    
    public void executeScriptGroup() {
        // 创建脚本组
        NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
            NullGroupNfTask.task("run task1(input) -> result1:String; export result1"),
            NullGroupNfTask.task("run task2(input) -> result2:String; export result2"),
            NullGroupNfTask.taskFile("scripts/task3.nf")
        );
        
        // 并发执行脚本组
        Map<String, Object> results = Null.of(input)
            .nfTasks(nfTaskGroup, "customThreadPool")
            .orElse(new HashMap<>());
    }
}
```

## 注意事项

1. **类型安全**：脚本中的类型需要与 Java 类型匹配
2. **任务注册**：任务需要先注册才能被脚本调用
4. **并发执行**：脚本组可以并发执行，但需要注意线程安全
5. **性能考虑**：脚本是运行时执行的，性能可能略低于直接调用任务
6. **错误处理**：脚本执行错误会抛出异常，需要自行处理

## 与任务/工具的区别

- **任务/工具**：使用 Java 代码实现，编译期检查，性能更好
- **NF 脚本**：使用脚本语言实现，运行时执行，更灵活但性能略低

## 使用场景

1. **动态配置**：通过脚本实现动态逻辑，无需重新编译
2. **业务规则**：将业务规则编写为脚本，便于修改和维护
3. **工作流编排**：通过脚本编排多个任务的执行流程
4. **A/B 测试**：通过脚本实现不同的业务逻辑分支

