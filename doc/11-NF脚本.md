# NF脚本

本文档介绍 NF 脚本语言的使用方法，用于执行动态逻辑。

## 概述

**NF 脚本**是框架提供的自定义脚本语言，用于执行动态逻辑。

**特点**：
- 支持变量定义和赋值
- 支持条件判断（if/else、switch）
- 支持循环（for）
- 支持任务调用
- 支持并发任务执行
- 支持导入 Java 类型和任务
- 支持导出变量

## 基本语法

### 变量定义

```nf
// 定义变量（声明并赋值）
String a = "123"
Integer b = 123
UserEntity user = new
user.setName("huanmin")

// 只声明不赋值
Integer a
String b
```

**变量命名规则**：
- 必须以字母或下划线开头
- 支持字母、数字、下划线的组合
- **不能以 `$` 开头**（`$` 前缀保留给系统变量使用）
- 不能使用保留关键字

**系统变量**（以 `$` 开头）：
- `$preValue` - 前一个任务的返回值
- `$params` - 参数集合
- `$threadFactoryName` - 线程池名称
- `$$nextTaskValue$$` - 导出值（export 的值）

### 字符串

**普通字符串**：使用双引号 `""`
```nf
String a = "123"
String b = "hello"
```

**模板字符串**：使用三个反引号 `` ``` ``，支持占位符 `{变量名}`，支持多行换行

String name = "world"

String message = `` ``` ``

Hello {name}

`` ``` ``  
// message = "Hello world"


// 多个占位符
Integer age = 18

String info = `` ``` `` 

Name: {name}, Age: {age}

`` ``` ``  

// info = "Name: world, Age: 18"



### 导入类型和任务

```nf
// 导入 Java 类型
import com.example.UserEntity

// 导入任务，起别名
task com.example.Test1Task as test1
task com.example.Test2Task as test2
```

### 调用任务

```nf
// 调用任务
run test1(a, b)

// 调用任务并绑定变量
run test1(a, b) -> result:String

// 多任务并发执行
run test1(a, b), test2(a, b) -> results:Map
```

### 条件判断

```nf
// if/else
if b > 100 {
    echo "b 大于 100"
} else {
    echo "b 小于等于 100"
}

// switch（注意：case 后面不带冒号，直接换行写语句）
switch b {
    case 100
        echo "b 等于 100"
    case 200
        echo "b 等于 200"
    default
        echo "b 是其他值"
}

// 多值匹配（用逗号分隔）
switch month {
    case 1, 2, 3
        echo "第一季度"
    case 4, 5, 6
        echo "第二季度"
    default
        echo "其他季度"
}
```

### 循环

**for 范围循环**：`for 变量名 in 起始值..结束值 { ... }`
- 起始值和结束值可以是整数字面量（如 `1..10`）或整数类型变量
- **只支持整数类型**（Integer、Long、Short、Byte），不支持小数
- 循环变量从起始值递增到结束值（包含边界值）

**for 集合迭代**：`for item in 集合变量 { ... }` 或 `for key, value in Map变量 { ... }`
- 支持 List、Set、Map、数组类型

**while 循环**：`while 条件 { ... }`

**循环控制**：
- `break` - 跳出当前循环
- `continue` - 跳过本次循环
- `breakall` - 跳出所有嵌套循环

```nf
// for 范围循环（常量范围）
for i in 1..10 {
    echo "value:{i}"
}

// for 动态范围循环（变量作为范围值）
Integer start = 1
Integer end = 5
Integer sum = 0
for i in start..end {
    sum = sum + i
}
// sum = 15 (1+2+3+4+5)

// for 动态范围支持计算后的变量
Integer base = 10
Integer offset = 5
Integer start2 = base - offset  // 5
Integer end2 = base + offset    // 15
for i in start2..end2 {
    echo "i:{i}"
}
// 循环从 5 到 15

// for 列表迭代
ArrayList list = new
list.add("a")
list.add("b")
for item in list {
    echo "item:{item}"
}

// for Map 迭代
Map map = new
map.put("key1", "value1")
map.put("key2", "value2")
for key, value in map {
    echo "key:{key}, value:{value}"
}

// for Set 迭代
HashSet set = new
set.add(1)
set.add(2)
for item in set {
    echo "item:{item}"
}

// while 循环
Integer i = 0
while i < 5 {
    echo "i:{i}"
    i = i + 1
}

// 循环控制
for i in 1..10 {
    if i == 5 {
        break      // 跳出当前循环
    }
    if i == 3 {
        continue   // 跳过本次循环
    }
    echo "i:{i}"
}

// breakall - 跳出所有嵌套循环
for i in 1..5 {
    for j in 1..5 {
        if i * j == 6 {
            breakall   // 跳出所有循环
        }
    }
}
```

### 运算符

```nf
// 算术运算符
+ - * / %     // 加、减、乘、除、取模

// 比较运算符
> < >= <=     // 大于、小于、大于等于、小于等于
== !=        // 等于、不等于

// 逻辑运算符
and / &&     // 逻辑与
or / ||      // 逻辑或
!            // 逻辑非

// 示例
if a > 10 and b < 20 {
    echo "a > 10 且 b < 20"
}

if a == 10 or b == 20 {
    echo "a == 10 或 b == 20"
}

// 也可以使用 && 和 ||
if a > 10 && b < 20 {
    echo "a > 10 且 b < 20"
}
```

### 类型判断

```nf
// instanceof - 判断对象类型（支持父子关系）
Object obj = "hello"
if obj instanceof String {
    echo "obj 是字符串类型"
}

// 支持精确类型匹配
ArrayList list = new
if list instanceof ArrayList {
    echo "list 是 ArrayList 类型"
}

// 支持父类/接口匹配（子类 instanceof 父类 返回 true）
Object obj2 = list
if obj2 instanceof Object {
    echo "obj2 是 Object 类型（父类匹配）"
}

// 支持全限定名类型
if obj2 instanceof java.util.List {
    echo "obj2 是 java.util.List 接口的实现类"
}
```

### 布尔值

```nf
// 布尔常量
Boolean flag1 = true
Boolean flag2 = false

if flag1 and !flag2 {
    echo "flag1 为 true 且 flag2 为 false"
}
```

### 关键字

以下为 NF 脚本的保留关键字，不能用作变量名：

| 分类 | 关键字 |
|------|--------|
| 导入相关 | `import`, `task`, `as` |
| 控制流 | `if`, `else`, `switch`, `case`, `default`, `while`, `for`, `in`, `range` |
| 循环控制 | `break`, `breakall`, `continue` |
| 执行相关 | `run`, `export`, `echo` |
| 逻辑运算符 | `and`, `or` |
| 布尔常量 | `true`, `false` |
| 对象创建 | `new` |
| 类型判断 | `instanceof` |
| 其他 | `this` |

### 导出变量

```nf
// 导出变量
export result

// 导出表达式结果
export a + b

// 导出模板字符串
export "result:{result}"
```

## 执行 NF 脚本

### 执行脚本文件

```java
// 执行 NF 脚本文件
String filePath = "path/to/script.nf";
Object result = Null.of(input)
    .nfTask(NullGroupNfTask.taskFile(filePath))
    .orElse(null);
```

### 执行脚本内容

```java
// 执行 NF 脚本内容
String script = "String a = '123'; run test1(a) -> result:String; export result";
Object result = Null.of(input)
    .nfTask(script, param1, param2)
    .orElse(null);
```

### 使用指定线程池

```java
// 使用指定线程池执行脚本
Object result = Null.of(input)
    .nfTask(script, "customThreadPool", param1, param2)
    .orElse(null);
```

## NF 脚本组并发执行

### 创建脚本组

```java
import com.gitee.huanminabc.nullchain.common.NullGroupNfTask;

// 创建 NF 脚本组
NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
    NullGroupNfTask.task("String a = '123'; run test1(a) -> result:String; export result"),
    NullGroupNfTask.taskFile("path/to/script2.nf")
);
```

### 并发执行脚本组

```java
// 并发执行 NF 脚本组
Map<String, Object> results = Null.of(input)
    .nfTasks(nfTaskGroup, "customThreadPool")
    .orElse(new HashMap<>());
```

## 完整示例

### 脚本文件示例（script.nf）

```nf
// 导入 Java 类型
import com.example.UserEntity

// 导入任务
task com.example.UserValidationTask as validate
task com.example.UserProcessingTask as process

// 定义变量
String userId = "123"
UserEntity user = new
user.setId(userId)

// 调用任务
run validate(user) -> isValid:Boolean

// 条件判断
if isValid {
    run process(user) -> processed:UserEntity
    export processed
} else {
    echo "用户验证失败"
    export null
}
```

### Java 代码示例

```java
public class NfScriptExample {
    
    public void executeScriptFile() {
        // 执行脚本文件
        String filePath = "scripts/user-process.nf";
        Object result = Null.of(input)
            .nfTask(NullGroupNfTask.taskFile(filePath))
            .orElse(null);
    }
    
    public void executeScriptContent() {
        // 执行脚本内容
        String script = "String a = '123'; " +
                       "run test1(a) -> result:String; " +
                       "export result";
        Object result = Null.of(input)
            .nfTask(script, param1, param2)
            .orElse(null);
    }
    
    public void executeScriptGroup() {
        // 创建脚本组
        NullGroupNfTask nfTaskGroup = NullGroupNfTask.buildGroup(
            NullGroupNfTask.task("run task1(input) -> result1:String; export result1"),
            NullGroupNfTask.task("run task2(input) -> result2:String; export result2"),
            NullGroupNfTask.taskFile("scripts/task3.nf")
        );
        
        // 并发执行脚本组
        Map<String, Object> results = Null.of(input)
            .nfTasks(nfTaskGroup, "customThreadPool")
            .orElse(new HashMap<>());
    }
}
```

## 注意事项

1. **类型安全**：脚本中的类型需要与 Java 类型匹配
2. **任务注册**：任务需要先注册才能被脚本调用
4. **并发执行**：脚本组可以并发执行，但需要注意线程安全
5. **性能考虑**：脚本是运行时执行的，性能可能略低于直接调用任务
6. **错误处理**：脚本执行错误会抛出异常，需要自行处理

## 与任务/工具的区别

- **任务/工具**：使用 Java 代码实现，编译期检查，性能更好
- **NF 脚本**：使用脚本语言实现，运行时执行，更灵活但性能略低

## 使用场景

1. **动态配置**：通过脚本实现动态逻辑，无需重新编译
2. **业务规则**：将业务规则编写为脚本，便于修改和维护
3. **工作流编排**：通过脚本编排多个任务的执行流程
4. **A/B 测试**：通过脚本实现不同的业务逻辑分支

