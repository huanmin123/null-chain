# 多级判空

本文档介绍 `NullCheck` 多级判空工具的使用方法。

## 概述

`NullCheck` 与 `NullChain.of()` 不同，该工具会**全部判定一遍**所有节点，收集所有为空的节点信息，然后统一处理。适用于需要检查多个字段是否为空，并统一记录日志和抛出异常的场景。

### 主要特点

- **全部判定**：不是遇到第一个空就终止，而是全部判定一遍所有节点
- **链路跟踪**：显示 `a->b->c?->d->e?->f` 格式（`?` 表示空节点）
- **统一处理**：收集所有空节点信息后统一抛出异常或返回结果

## 创建判空链

```java
// 创建多级判空工具
NullCheck<User> check = Null.ofCheck(user);
```

## 基本操作

### of() - 检查字段是否为空

```java
// 检查多个字段是否为空
boolean hasNull = Null.ofCheck(user)
    .of(User::getId)      // 检查用户ID是否为空
    .of(User::getName)    // 继续检查用户名为空
    .of(User::getEmail)   // 继续检查邮箱为空
    .is();  // 返回是否有空值
```

### map() - 映射到内部对象并继续判空

```java
// 进入内部对象继续判空
boolean hasNull = Null.ofCheck(user)
    .map(User::getAddress)      // 进入 Address 对象
    .of(Address::getCity)       // 检查城市是否为空
    .of(Address::getStreet)    // 检查街道是否为空
    .is();  // 返回是否有空值
```

### is() - 判断是否有空值

```java
// 返回是否有空值
boolean hasNull = Null.ofCheck(user)
    .of(User::getId)
    .of(User::getName)
    .of(User::getEmail)
    .is();  // 如果有任何节点为空则返回 true，否则返回 false
```

### doThrow() - 抛出异常

```java
// 如果有空值，抛出异常
Null.ofCheck(user)
    .of(User::getId)
    .of(User::getName)
    .of(User::getEmail)
    .doThrow(IllegalArgumentException.class);  // 抛出指定类型的异常

// 带自定义消息的异常
Null.ofCheck(user)
    .of(User::getId)
    .of(User::getName)
    .of(User::getEmail)
    .doThrow(IllegalArgumentException.class, "用户信息不完整");

// 使用默认异常类型
Null.ofCheck(user)
    .of(User::getId)
    .of(User::getName)
    .of(User::getEmail)
    .doThrow("用户信息不完整");

// 使用默认异常类型和默认消息
Null.ofCheck(user)
    .of(User::getId)
    .of(User::getName)
    .of(User::getEmail)
    .doThrow();
```

## 完整示例

```java
import com.gitee.huanminabc.nullchain.Null;

public class CheckExample {
    
    public void basicCheck() {
        // 检查用户的基本信息
        boolean hasNull = Null.ofCheck(user)
            .of(User::getId)
            .of(User::getName)
            .of(User::getEmail)
            .is();
        
        if (hasNull) {
            System.out.println("用户信息不完整");
        }
    }
    
    public void nestedCheck() {
        // 检查嵌套对象
        boolean hasNull = Null.ofCheck(user)
            .map(User::getAddress)      // 进入 Address 对象
            .of(Address::getCity)       // 检查城市
            .of(Address::getStreet)     // 检查街道
            .of(Address::getZipCode)    // 检查邮编
            .is();
    }
    
    public void throwException() {
        // 如果有空值，抛出异常
        Null.ofCheck(user)
            .of(User::getId, "用户ID为空")
            .of(User::getName, "用户名为空")
            .of(User::getEmail, "邮箱为空")
            .doThrow(IllegalArgumentException.class, "用户信息不完整");
    }
    
    public void complexCheck() {
        // 复杂的多级检查
        Null.ofCheck(user)
            .of(User::getId)
            .of(User::getName)
            .map(User::getAddress)
            .of(Address::getCity)
            .of(Address::getStreet)
            .map(User::getProfile)
            .of(Profile::getPhone)
            .doThrow(IllegalArgumentException.class, "用户信息不完整");
    }
}
```

## 与 NullChain.of() 的区别

### NullChain.of() - 短路模式

```java
// 遇到第一个空值就终止
String result = Null.of(user)
    .of(User::getName)      // 如果用户名为空，链变为空链，后续不再执行
    .of(User::getEmail)     // 不会执行
    .map(User::getProfile)  // 不会执行
    .orElse("默认值");
```

### NullCheck - 全部判定模式

```java
// 全部判定一遍，收集所有空值信息
boolean hasNull = Null.ofCheck(user)
    .of(User::getName)      // 检查并记录
    .of(User::getEmail)     // 继续检查并记录
    .map(User::getProfile)  // 继续检查并记录
    .is();  // 返回是否有空值
```

## 使用场景

### 1. 参数验证

```java
// 验证请求参数
public void validateRequest(CreateUserRequest request) {
    Null.ofCheck(request)
        .of(CreateUserRequest::getUsername)
        .of(CreateUserRequest::getPassword)
        .of(CreateUserRequest::getEmail)
        .doThrow(IllegalArgumentException.class, "请求参数不完整");
}
```

### 2. 数据完整性检查

```java
// 检查数据完整性
public void checkDataIntegrity(User user) {
    boolean isValid = Null.ofCheck(user)
        .of(User::getId)
        .of(User::getName)
        .map(User::getAddress)
        .of(Address::getCity)
        .is();
    
    if (!isValid) {
        // 记录日志或执行其他操作
        log.warn("用户数据不完整: {}", user.getId());
    }
}
```

### 3. 批量验证

```java
// 批量验证多个对象
public void validateUsers(List<User> users) {
    for (User user : users) {
        Null.ofCheck(user)
            .of(User::getId)
            .of(User::getName)
            .doThrow(IllegalArgumentException.class, "用户数据不完整");
    }
}
```

## 注意事项

1. **全部判定**：与 `NullChain.of()` 不同，`NullCheck` 会全部判定一遍所有节点
2. **链路跟踪**：异常消息会包含完整的链路信息（如 `a->b->c?->d->e?->f`）
3. **统一处理**：收集所有空节点信息后统一抛出异常或返回结果
4. **性能考虑**：由于需要全部判定，性能可能略低于短路模式

