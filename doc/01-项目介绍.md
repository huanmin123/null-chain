# 项目介绍

## 为什么需要 Null-Chain？

### null 的困境

在 Java 开发中，`null` 被广泛用作"没有"的表示方式。例如 `getUser(userId)` 返回 `null` 表示"找不到这个 userId 对应的 user"。虽然理论上应该抛异常或使用 `Optional`，但现实是，使用 `null` 表示"没有"已经成为某种"共识"。

一旦一个东西没有，对其进行某个操作就是未定义的。例如 `getUser(userId).name` 可能就会抛出 `NullPointerException`，因为 user 没有的情况下，获取其 name 也就没有意义。程序不会晓得没有 user 的情况下 name 应该怎么处理。如果不写代码特殊照顾，程序就只能抛出 NPE 等价的错误。

于是这就需要程序员必须不断地做 NPE 检查。而人做这种工作，在没有其他支持下，有遗漏是必然的。某些遗漏造成的 NPE 会带来灾难性的结果。你能想象一个做手术的机器人程序，或者飞机飞控程序出现一个 NPE 是什么结果吗？

### 现有解决方案的局限性

对于 NPE 问题，业界有几种主流方案：

#### 1. 完全不接受 null（如 Option 类型）

完全不接受 `null`，但"没有"这个概念得另外想办法。比如每个字段 `foo`，都得弄一个对应的 `hasFoo` 的字段表示。取值也总得弄两次。但这样作和上面的问题是等价的，会遗漏 `if (foo != null)` 的程序员肯定也会遗漏 `if (hasFoo)`。要不就把 `foo` 和 `hasFoo` 外边套一层，逼着程序员用 `getOrElse` 这样的方式做 NPE 检查。`Optional` 这类方案就是如此。

**问题**：在 Java 中如果经常使用 `Optional` 的会发现很痛苦。因为 `Optional` 只能处理 `null`，并且不支持字符串的空和各种集合的内部长度空。而遇到多值判空或者链路判空，那么就会显得非常啰嗦而且麻烦，还不如直接使用 `if` 来的实在。

#### 2. 允许 null，但控制 null 的范围（如 Kotlin）

允许 `null`，但是控制 `null` 的范围。假设程序在对外接触的界面上（比如接口的 controller，访问 DB 时）进行判空，处理所有"没有"的情况。然后处理干净后对内部的程序总是 `not null` 的，不用管"没有"。编译器就负责保证那些 `not null` 的部分肯定不出问题。Kotlin 是这么干的。

**问题**：需要语言层面的支持，Java 无法直接使用。

#### 3. 允许 null，通过语法糖简化处理（如 JavaScript）

允许 `null`，通过与语法糖的形式让每次有 `null` 时的处理写的方便点。比如 JS 里你可以这样写 `(getUser(userId) || {}).name` 或者 `_.get(getUser(userId), 'name')`，这样用户找不到，至少能得到一个 `undefined` 的 name，而不会 NPE。简短的语法糖可以提高开发者做处理的概率。

**问题**：Java 没有这样的语法糖，如果用 Java 就得写几行，程序员也许会更倾向于漏掉。

### 空字符串的困扰

`""` 是比 `null` 更加烦人的，在很多时候它就是一个中间状态，会出现四种情况：`""`、`"   "`（空格）、`null`、`"xxx"`。

想象一下：小丽是一名数据分析师，她正在处理一大批数据。其中有一个字段，有时候是 `""` 或者 `"   "`，有时候是 `null`，还有时候是具体的数值 `"xxx"`。这让小丽很是头疼。因为 `""` 和 `null` 在数据处理中的意义完全不同，她需要额外写很多代码来处理这种中间状态。而且，`""` 还可能表示数据尚未填写或者填写了但被误清空或者是误输入 `"   "`。小丽不禁抱怨："这个 `""` 真是太狡猾了，比 `null` 还难对付！"

### 0 与 null 的哲学

让我们用一些生动的例子来理解 `0` 和 `null` 的区别：

- **桌子上有空杯子**：杯子里有 `0 mL` 水
- **桌子上没有杯子**：杯子里有 `null mL` 水
- **往空杯子里倒入一些水**：杯子里有 `114 mL` 水
- **往没有杯子的桌子上倒入等量水**：你妈看见桌子上地上都是水拿出铜头皮带把你抽得如键山雏一般旋转。

- **北纬51度，东经0度**：伦敦
- **北纬51度，东经null度**：幻想乡

- **上午8点0分**：周末这个点我表姐极有可能在赖床
- **上午8点null分**：表坏了

- **往一张有0元的银行卡里转50块钱**：卡的主人会拿着卡去吃汉堡
- **往一张有null元的银行卡里转50块钱**：银行服务不可用

- **计算 5-0**：`5`
- **计算 5-null**：程序错误

### 三种状态的哲学

```
0说："身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。"
null说："菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。"
""说："我思故我在，尘埃亦随心，若得心自在，何处不净土。"
```


### 解决空问题需要的特性

我们研究了多种编程语言对空值的处理方式，发现对空处理比较好的语言都具备以下特性。Null-Chain 框架实现了这些特性，并在某些方面更加强大和友好：

#### 1. 半开放半严谨

**特性说明**：因为空是无法彻底断绝的，只能尽量做到早发现早解决。完全禁止 `null` 会导致代码过于复杂，完全允许 `null` 又会导致 NPE 频发。

**Null-Chain 实现**：
- 允许 `null` 的存在，但通过链式操作强制处理
- 提供 `orElse()`、`orElseNull()` 等方法，让开发者明确处理空值
- 支持 `getSafe()` 方法，在需要时抛出检查异常，强制调用者处理

```java
// 半开放：允许 null 存在
User user = getUserById(1);  // 可能返回 null

// 半严谨：强制处理空值
String name = Null.of(user)
    .map(User::getName)
    .orElse("UNKNOWN");  // 必须提供默认值
```

#### 2. 不允许空传播

**特性说明**：空值不应该在链式调用中传播，一旦遇到空值，后续操作应该被跳过，而不是抛出异常。

**Null-Chain 实现**：
- 采用短路机制，遇到空值立即停止后续操作
- 所有链式操作都是空值安全的，不会抛出 `NullPointerException`
- 支持 `ifGo()`、`ifNeGo()` 等条件判断，进一步控制执行流程

```java
// 空值不会传播，后续操作自动跳过
String result = Null.of(user)
    .map(User::getName)      // 如果 user 为 null，后续操作跳过
    .map(String::toUpperCase) // 如果 name 为 null，后续操作跳过
    .orElse("UNKNOWN");       // 最终返回默认值，不会抛出异常
```

#### 3. 空可以有默认值来代替

**特性说明**：当值为空时，应该能够提供默认值，而不是返回 `null` 或抛出异常。

**Null-Chain 实现**：
- 提供 `orElse()` 方法，支持固定默认值
- 提供 `orElse(Supplier)` 方法，支持动态生成默认值
- 提供 `or()` 方法，支持链式默认值处理

```java
// 固定默认值
String name = Null.of(user)
    .map(User::getName)
    .orElse("默认名称");

// 动态默认值
String name = Null.of(user)
    .map(User::getName)
    .orElse(() -> "用户" + userId);

// 链式默认值
String name = Null.of(user)
    .map(User::getName)
    .or(() -> getDefaultName())
    .orElse("最终默认值");
```

#### 4. 延迟评估

**特性说明**：虽然变量是空，但是没用到的时候就不会报错。只有在真正需要使用值的时候才进行评估。

**Null-Chain 实现**：
- 采用延迟执行机制，只有在终结操作时才真正执行
- 支持短路操作，遇到空值立即停止，不执行后续操作
- 对于明显为 `null` 的值，会直接返回空链，避免创建不必要的对象

```java
// 延迟评估：只有在调用 orElse() 时才真正执行
NullChain<String> chain = Null.of(user)
    .map(User::getName)
    .map(String::toUpperCase);  // 此时还没有执行

// 只有在终结操作时才执行
String result = chain.orElse("UNKNOWN");  // 此时才真正执行上面的操作
```

#### 5. 空值日志

**特性说明**：在空链中实现了更加强大的日志精准定位，能够准确追踪空值出现的位置和原因。

**Null-Chain 实现**：
- 提供完整的操作日志追踪，记录每一步操作
- 支持链路信息显示，如 `a->b->c?->d->e?->f`（`?` 表示空节点）
- 异常信息包含完整的链路信息，便于快速定位问题
- 支持 `getLinkLog()` 方法，获取完整的操作日志

```java
// 空值日志：异常信息包含完整的链路信息
try {
    String name = Null.of(user)
        .map(User::getRole)
        .map(Role::getName)
        .get();  // 如果为空，异常信息会显示：user->role?->name
} catch (Exception e) {
    // 异常信息会包含完整的链路：user->role?->name
    // 可以快速定位到 role 为空
}

// 获取操作日志
NullChain<String> chain = Null.of(user)
    .map(User::getName)
    .map(String::toUpperCase);
String log = chain.getLinkLog();  // 获取完整的操作日志
```

#### 6. 模式匹配（部分支持）

**特性说明**：部分语言（如 Rust、Scala）使用模式匹配处理空值，但在处理空的感觉上和使用 `if` 方式没啥大的区别（仁者见仁智者见智）。

**Null-Chain 实现**：
- 提供 `ifPresent()`、`ifPresentOrElse()` 等方法，类似模式匹配
- 提供 `ifGo()`、`ifNeGo()` 等条件判断，支持更灵活的控制流
- 提供 `collect()` 方法，支持收集链中多个节点的值

```java
// 类似模式匹配的方式
Null.of(user)
    .map(User::getName)
    .ifPresent(name -> {
        // 处理有值的情况
        System.out.println("用户名: " + name);
    });

// 带 else 的模式匹配
Null.of(user)
    .map(User::getName)
    .ifPresentOrElse(
        name -> System.out.println("用户名: " + name),
        () -> System.out.println("用户名为空")
    );

// 条件判断
String result = Null.of(user)
    .ifGo(u -> u.getAge() != null && u.getAge() >= 18)
    .map(User::getName)
    .orElse("未成年用户");
```

### Null-Chain 的额外优势

除了实现上述特性外，Null-Chain 还提供了更多强大的功能：

- **集合和流操作**：原生支持集合、数组、Stream 的空值安全处理
- **HTTP 请求**：内置 HTTP 请求支持，空值安全
- **JSON 处理**：内置 JSON 序列化/反序列化，空值安全
- **日期操作**：内置日期格式化、偏移、比较等功能
- **计算操作**：内置数值计算，使用 BigDecimal 确保精度
- **任务编排**：支持任务、工具、脚本的编排和并发执行
- **多级判空**：支持批量判空，统一处理多个字段的空值检查

## 什么是 Null-Chain？

**Null-Chain** 是一个强大的空值安全链式编程框架，提供了类似 `Optional` 但功能更丰富的链式 API。通过 Null 链，可以优雅地处理可能为空的值，彻底避免 `NullPointerException`。

## 核心特性

- 🛡️ **空值安全**：所有操作都是空值安全的，不会抛出 `NullPointerException`
- 🔗 **链式调用**：支持流畅的链式编程风格，代码更简洁易读
- 🎯 **类型安全**：通过泛型保证类型安全，编译期即可发现类型错误
- 🚀 **高性能**：延迟执行和短路操作，性能优异
- 📦 **模块化**：提供多个模块，按需引入
- 🌐 **Spring集成**：完美集成 Spring Boot 生态
- 📝 **完整日志**：提供完整的操作日志追踪，便于调试
- 🔄 **任务编排**：支持任务、工具、脚本的编排和并发执行
- 🔧 **JDK兼容**：支持 JDK 8 到最新版本

## 项目架构

```
null-chain/
├── null-chain-core          # 核心模块，提供基础的链式操作功能
├── null-chain-boot-starter  # Spring Boot 自动配置模块
├── null-chain-boot-dubbo    # Dubbo 集成模块
├── null-chain-work          # 工作流模块
└── null-chain-test          # 测试模块
```

## 解决的问题

### 1. NullPointerException 问题

**传统代码的问题：**

```java
// 传统方式 - 容易出现 NullPointerException
User user = getUserById(1);
String name = user.getName();  // 如果 user 为 null，抛出 NPE
String upperName = name.toUpperCase();  // 如果 name 为 null，抛出 NPE
```

**使用 Null-Chain 解决：**

```java
// 使用 Null-Chain - 完全空值安全
String upperName = Null.of(getUserById(1))
    .map(User::getName)
    .map(String::toUpperCase)
    .orElse("UNKNOWN");
```

### 2. 深层嵌套判空问题

**传统代码的问题：**

```java
// 传统方式 - 多层嵌套判空，代码冗长
String roleName = null;
if (user != null) {
    Role role = user.getRole();
    if (role != null) {
        roleName = role.getName();
    }
}
```

**使用 Null-Chain 解决：**

```java
// 使用 Null-Chain - 链式调用，简洁优雅
String roleName = Null.of(user)
    .map(User::getRole)
    .map(Role::getName)
    .orElse("默认角色");
```

### 3. 集合操作中的空值处理

**传统代码的问题：**

```java
// 传统方式 - 需要手动判空
List<String> names = new ArrayList<>();
if (users != null) {
    for (User user : users) {
        if (user != null && user.getName() != null) {
            names.add(user.getName());
        }
    }
}
```

**使用 Null-Chain 解决：**

```java
// 使用 Null-Chain - 使用 ofStream() 直接创建流，自动过滤空值
List<String> names = Null.ofStream(users)
    .map(User::getName)
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
```

## 与 Optional 和 Stream 的对比

### Null-Chain vs Optional

| 特性 | Optional | Null-Chain | 优势说明 |
|------|----------|------------|----------|
| **空值安全** | ✅ | ✅ | 两者都提供空值安全 |
| **链式操作** | ✅ | ✅ | 两者都支持链式调用 |
| **集合支持** | ❌ | ✅ | Null-Chain 原生支持集合和数组操作 |
| **流操作** | ❌ | ✅ | Null-Chain 提供 `ofStream()` 方法，直接支持流操作 |
| **字符串空值处理** | ❌ | ✅ | Null-Chain 可以处理空字符串 `""` 和空白字符串 |
| **多值判空** | ❌ | ✅ | Null-Chain 支持批量判空，`Optional` 需要嵌套使用 |
| **链路判空** | ❌ | ✅ | Null-Chain 支持多级对象访问，代码更简洁 |
| **HTTP 请求** | ❌ | ✅ | Null-Chain 内置 HTTP 请求支持 |
| **JSON 处理** | ❌ | ✅ | Null-Chain 内置 JSON 序列化/反序列化 |
| **日期操作** | ❌ | ✅ | Null-Chain 内置日期格式化、偏移、比较等功能 |
| **任务编排** | ❌ | ✅ | Null-Chain 支持任务、工具、脚本的编排 |
| **并发执行** | ❌ | ✅ | Null-Chain 支持任务组的并发执行 |
| **日志追踪** | ❌ | ✅ | Null-Chain 提供完整的操作日志追踪 |
| **类型转换** | ❌ | ✅ | Null-Chain 提供 `type()` 方法进行类型恢复 |
| **对象复制** | ❌ | ✅ | Null-Chain 支持浅拷贝和深拷贝 |

**关键优势**：`Optional` 在处理多值判空或链路判空时会显得非常啰嗦，而 Null-Chain 提供了更简洁的语法，让代码更易读易写。

### Null-Chain vs Stream

| 特性 | Stream | Null-Chain | 优势说明 |
|------|--------|------------|----------|
| **空值安全** | ❌ | ✅ | Stream 需要手动判空，Null-Chain 自动处理 |
| **集合操作** | ✅ | ✅ | 两者都支持集合操作 |
| **链式调用** | ✅ | ✅ | 两者都支持链式调用 |
| **单值处理** | ❌ | ✅ | Null-Chain 可以处理单个值，Stream 只能处理集合 |
| **HTTP 请求** | ❌ | ✅ | Null-Chain 内置 HTTP 请求支持 |
| **JSON 处理** | ❌ | ✅ | Null-Chain 内置 JSON 处理 |
| **任务编排** | ❌ | ✅ | Null-Chain 支持任务编排和并发执行 |
| **日志追踪** | ❌ | ✅ | Null-Chain 提供完整的操作日志追踪 |

## 适用场景

- API 接口返回值处理
- 数据库查询结果处理
- 配置文件读取
- 集合数据处理
- HTTP 请求处理
- 多级对象属性访问
- 条件过滤和转换
- 任务编排和并发执行

## 使用要求

使用 Null-Chain 时，需要注意以下要求：

1. **类必须实现 get/set 方法**（强制必须实现，否则编译不通过）
2. **类必须有空构造方法**（必须）
3. **类中全部字段必须使用包装类型**（必须）
4. **可以使用 lombok 的 @Data 注解来实现**

## 版本信息

- **当前版本**：v1.1.3-RELEASE
- **JDK要求**：JDK 8 及以上（已测试 JDK 8~25）
- **查看版本更新**：[CHANGELOG.md](./CHANGELOG.md)

## 参考资源

- **项目地址**：https://gitee.com/huanminabc/null-chain
- **Maven Central**：https://central.sonatype.com/search?q=null-chain
- **详细文档**：https://gitee.com/huanminabc/null-chain/tree/master/doc
- **问题反馈**：https://gitee.com/huanminabc/null-chain/issues

