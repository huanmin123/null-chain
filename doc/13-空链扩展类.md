# 空链扩展类

本文档介绍 `NullExt` 空链扩展类的使用方法，允许在对象上直接调用链式操作。

## 概述

`NullExt` 是一个接口，允许在任何对象上直接调用链式操作，而不需要先调用 `Null.of()`。对象需要实现 `NullExt` 接口才能使用。

### 主要特点

- **直接链式操作**：在对象上直接调用链式方法，无需包装
- **空值安全**：处理空对象的情况
- **类型转换**：支持类型转换操作
- **空对象处理**：使用 `Null.createEmpty()` 创建的空对象可以通过空链方式处理

## 使用方式

### 1. 对象实现 NullExt 接口

```java
import com.gitee.huanminabc.nullchain.NullExt;

public class User implements NullExt<User> {
    private String name;
    private Integer age;
    
    // getter/setter 方法
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Integer getAge() { return age; }
    public void setAge(Integer age) { this.age = age; }
}
```

### 2. 直接调用链式操作

```java
// 对象实现 NullExt 后，可以直接调用链式方法
User user = new User();
user.setName("张三");
user.setAge(25);

// 直接调用链式操作
String upperName = user
    .map(User::getName)
    .map(String::toUpperCase)
    .orElse("UNKNOWN");
```

### 3. 处理空对象

```java
// 如果对象可能为空，使用 orEmpty() 方法
User user = getUserById(1);
User safeUser = Null.orEmpty(user, User.class);

// 现在可以安全地调用链式操作
String name = safeUser
    .map(User::getName)
    .orElse("默认名称");
```

### 4. 创建空对象

```java
// 创建空对象，返回的不是 null 而是一个空对象
User emptyUser = Null.createEmpty(User.class);

// 空对象可以安全地调用链式操作，不会抛出 NullPointerException
String name = emptyUser
    .map(User::getName)
    .orElse("默认名称");  // 返回 "默认名称"
```

## 完整示例

```java
import com.gitee.huanminabc.nullchain.NullExt;
import com.gitee.huanminabc.nullchain.Null;

public class User implements NullExt<User> {
    private String name;
    private Integer age;
    private Address address;
    
    // getter/setter 方法
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Integer getAge() { return age; }
    public void setAge(Integer age) { this.age = age; }
    
    public Address getAddress() { return address; }
    public void setAddress(Address address) { this.address = address; }
}

public class Address implements NullExt<Address> {
    private String city;
    private String street;
    
    public String getCity() { return city; }
    public void setCity(String city) { this.city = city; }
    
    public String getStreet() { return street; }
    public void setStreet(String street) { this.street = street; }
}

public class Example {
    
    public void directChainOperation() {
        // 对象实现 NullExt 后，可以直接调用链式方法
        User user = new User();
        user.setName("张三");
        
        // 直接调用链式操作
        String upperName = user
            .map(User::getName)
            .map(String::toUpperCase)
            .orElse("UNKNOWN");
    }
    
    public void handleNullObject() {
        // 处理可能为空的对象
        User user = getUserById(1);
        
        // 使用 orEmpty() 确保对象不为 null
        User safeUser = Null.orEmpty(user, User.class);
        
        // 现在可以安全地调用链式操作
        String name = safeUser
            .map(User::getName)
            .orElse("默认名称");
    }
    
    public void createEmptyObject() {
        // 创建空对象
        User emptyUser = Null.createEmpty(User.class);
        
        // 空对象可以安全地调用链式操作
        String name = emptyUser
            .map(User::getName)
            .orElse("默认名称");  // 返回 "默认名称"
        
        // 多级操作
        String city = emptyUser
            .map(User::getAddress)
            .map(Address::getCity)
            .orElse("未知城市");  // 返回 "未知城市"
    }
    
    public void nestedObjects() {
        // 嵌套对象的链式操作
        User user = new User();
        Address address = new Address();
        address.setCity("北京");
        user.setAddress(address);
        
        // 直接调用链式操作
        String city = user
            .map(User::getAddress)
            .map(Address::getCity)
            .orElse("未知城市");
    }
}
```

## 与 Null.of() 的区别

### Null.of() - 包装方式

```java
// 需要先包装对象
String name = Null.of(user)
    .map(User::getName)
    .orElse("默认名称");
```

### NullExt - 直接调用方式

```java
// 对象实现 NullExt 后，可以直接调用
String name = user
    .map(User::getName)
    .orElse("默认名称");
```

## 工具方法

### orEmpty() - 空对象处理

```java
// 如果对象为空，返回空对象；否则返回原对象
User user = getUserById(1);
User safeUser = Null.orEmpty(user, User.class);

// 现在可以安全地调用链式操作
String name = safeUser
    .map(User::getName)
    .orElse("默认名称");
```

### createEmpty() - 创建空对象

```java
// 创建空对象，返回的不是 null 而是一个空对象
User emptyUser = Null.createEmpty(User.class);

// 空对象可以安全地调用链式操作
String name = emptyUser
    .map(User::getName)
    .orElse("默认名称");
```

## 使用场景

### 1. ORM 操作场景（推荐）

**最常见的应用场景**：在 DAO 层让所有实体类实现 `NullExt` 接口，这样在 Service 层或 Controller 层调用时就不用担心空值问题了。

#### DAO 层实现

```java
import com.gitee.huanminabc.nullchain.NullExt;
import com.gitee.huanminabc.nullchain.Null;
import org.springframework.stereotype.Repository;

// 实体类实现 NullExt 接口
@Entity
@Table(name = "user")
public class UserEntity implements NullExt<UserEntity> {
    @Id
    private Long id;
    private String name;
    private Integer age;
    private String email;
    
    // getter/setter 方法
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Integer getAge() { return age; }
    public void setAge(Integer age) { this.age = age; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

// DAO 层：使用 orEmpty() 确保返回的对象不为 null
@Repository
public class UserDao {
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 根据 ID 查询用户
     * 使用 orEmpty() 确保返回的对象不为 null，即使数据库中没有记录
     */
    public UserEntity findById(Long id) {
        UserEntity user = userMapper.selectById(id);
        return Null.orEmpty(user, UserEntity.class);
    }
    
    /**
     * 根据用户名查询用户
     */
    public UserEntity findByName(String name) {
        UserEntity user = userMapper.selectByName(name);
        return Null.orEmpty(user, UserEntity.class);
    }
    
    /**
     * 根据邮箱查询用户
     */
    public UserEntity findByEmail(String email) {
        UserEntity user = userMapper.selectByEmail(email);
        return Null.orEmpty(user, UserEntity.class);
    }
}
```

#### Service 层使用

```java
import org.springframework.stereotype.Service;

@Service
public class UserService {
    
    @Autowired
    private UserDao userDao;
    
    /**
     * 获取用户名称（大写）
     * 不需要担心 user 为 null，因为 DAO 层已经处理了
     */
    public String getUserName(Long userId) {
        UserEntity user = userDao.findById(userId);
        
        // 直接使用链式操作，不需要 Null.of() 包装
        return user
            .map(UserEntity::getName)
            .map(String::toUpperCase)
            .orElse("UNKNOWN");
    }
    
    /**
     * 检查用户是否为成年人
     */
    public boolean isAdult(Long userId) {
        UserEntity user = userDao.findById(userId);
        
        // 直接使用链式操作
        return user
            .map(UserEntity::getAge)
            .map(age -> age >= 18)
            .orElse(false);
    }
    
    /**
     * 获取用户邮箱，如果为空则返回默认值
     */
    public String getUserEmail(Long userId) {
        UserEntity user = userDao.findById(userId);
        
        // 直接使用链式操作
        return user
            .map(UserEntity::getEmail)
            .orElse("no-email@example.com");
    }
    
    /**
     * 多级对象访问
     */
    public String getUserCity(Long userId) {
        UserEntity user = userDao.findById(userId);
        
        // 如果 UserEntity 有 Address 属性，也可以直接链式访问
        return user
            .map(UserEntity::getAddress)
            .map(Address::getCity)
            .orElse("未知城市");
    }
}
```

#### Controller 层使用

```java
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    /**
     * 获取用户信息
     * 完全不用担心空值问题
     */
    @GetMapping("/{id}")
    public Map<String, Object> getUserInfo(@PathVariable Long id) {
        UserEntity user = userDao.findById(id);
        
        Map<String, Object> result = new HashMap<>();
        result.put("name", user.map(UserEntity::getName).orElse("未知用户"));
        result.put("age", user.map(UserEntity::getAge).orElse(0));
        result.put("email", user.map(UserEntity::getEmail).orElse("无邮箱"));
        result.put("isAdult", user.map(UserEntity::getAge).map(age -> age >= 18).orElse(false));
        
        return result;
    }
}
```

#### 优势说明

1. **DAO 层统一处理**：在 DAO 层使用 `Null.orEmpty()` 统一处理，确保返回的对象不为 null
2. **Service 层无需判空**：Service 层可以直接使用链式操作，不需要额外的空值判断
3. **代码更简洁**：不需要在每个地方都写 `Null.of()` 包装
4. **类型安全**：编译期即可发现类型错误
5. **性能优化**：避免了重复的空值检查

### 2. 对象直接链式操作

当对象已经确定不为空，并且需要频繁进行链式操作时，使用 `NullExt` 可以简化代码：

```java
// 使用 NullExt
String name = user
    .map(User::getName)
    .map(String::toUpperCase)
    .orElse("UNKNOWN");

// 不使用 NullExt（需要包装）
String name = Null.of(user)
    .map(User::getName)
    .map(String::toUpperCase)
    .orElse("UNKNOWN");
```

### 3. 空对象安全处理

当对象可能为空，但需要安全地调用链式操作时：

```java
// 使用 orEmpty() 确保对象不为 null
User safeUser = Null.orEmpty(user, User.class);
String name = safeUser
    .map(User::getName)
    .orElse("默认名称");
```

### 4. 创建空对象

当需要创建一个空对象，但不想返回 null 时：

```java
// 创建空对象
User emptyUser = Null.createEmpty(User.class);

// 空对象可以安全地调用链式操作
String name = emptyUser
    .map(User::getName)
    .orElse("默认名称");
```

## 注意事项

1. **对象必须实现 NullExt 接口**：只有实现了 `NullExt` 接口的对象才能直接调用链式方法
2. **空对象处理**：使用 `Null.createEmpty()` 创建的空对象不是 null，而是一个空对象，可以安全地调用链式操作
3. **性能考虑**：直接调用链式操作与使用 `Null.of()` 包装的性能基本相同
4. **类型安全**：通过泛型保证类型安全，编译期即可发现类型错误

## 支持的链式操作

`NullExt` 继承了 `NullChainExt`，支持所有 `NullChain` 的操作：

- **映射操作**：`map()`, `flatChain()`, `flatOptional()`
- **条件判断**：`ifGo()`, `ifNeGo()`, `of()`, `isNull()`
- **执行操作**：`then()`, `peek()`
- **默认值**：`or()`, `orElse()`, `orElseNull()`
- **类型转换**：`type()`, `json()`, `fromJson()`
- **日期操作**：`dateFormat()`, `dateOffset()`, `dateCompare()`, `dateBetween()`
- **对象复制**：`copy()`, `deepCopy()`, `pick()`
- **终结操作**：`get()`, `getSafe()`, `is()`, `non()`, `ifPresent()`, `collect()`

## 最佳实践

### ORM 场景的最佳实践

1. **在实体类中实现 NullExt 接口**
   ```java
   @Entity
   public class UserEntity implements NullExt<UserEntity> {
       // 实体字段和 getter/setter
   }
   ```

2. **在 DAO 层统一使用 orEmpty() 处理**
   ```java
   public UserEntity findById(Long id) {
       UserEntity user = userMapper.selectById(id);
       return Null.orEmpty(user, UserEntity.class);
   }
   ```

3. **在 Service 层直接使用链式操作**
   ```java
   public String getUserName(Long userId) {
       UserEntity user = userDao.findById(userId);
       return user.map(UserEntity::getName).orElse("UNKNOWN");
   }
   ```

### 注意事项

1. **DAO 层统一处理**：建议在 DAO 层统一使用 `orEmpty()` 处理，而不是在每个 Service 方法中处理
2. **避免返回 null**：使用 `orEmpty()` 或 `createEmpty()` 确保不返回 null
3. **性能考虑**：`orEmpty()` 和 `createEmpty()` 的性能开销很小，可以放心使用
4. **类型安全**：确保实体类正确实现了 `NullExt` 接口

## 总结

`NullExt` 提供了一种更直接的方式来使用链式操作，特别适合以下场景：

1. **ORM 操作场景**（最推荐）：在 DAO 层统一处理，Service 层直接使用
2. 对象已经确定不为空
3. 需要频繁进行链式操作
4. 需要处理空对象但不想返回 null
5. 希望代码更简洁易读

通过实现 `NullExt` 接口，可以让对象直接支持链式操作，提升代码的可读性和简洁性。特别是在 ORM 场景中，在 DAO 层统一处理后，整个应用层都可以安全地使用链式操作，无需担心空值问题。

